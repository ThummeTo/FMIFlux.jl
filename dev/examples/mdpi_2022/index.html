<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MDPI 2022 Â· FMIFlux.jl</title><meta name="title" content="MDPI 2022 Â· FMIFlux.jl"/><meta property="og:title" content="MDPI 2022 Â· FMIFlux.jl"/><meta property="twitter:title" content="MDPI 2022 Â· FMIFlux.jl"/><meta name="description" content="Documentation for FMIFlux.jl."/><meta property="og:description" content="Documentation for FMIFlux.jl."/><meta property="twitter:description" content="Documentation for FMIFlux.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FMIFlux.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../simple_hybrid_CS/">Simple CS-NeuralFMU</a></li><li><a class="tocitem" href="../simple_hybrid_ME/">Simple ME-NeuralFMU</a></li><li><a class="tocitem" href="../growing_horizon_ME/">Growing Horizon ME-NeuralFMU</a></li><li><a class="tocitem" href="../juliacon_2023/">JuliaCon 2023</a></li><li class="is-active"><a class="tocitem" href>MDPI 2022</a><ul class="internal"><li><a class="tocitem" href="#Keywords"><span>Keywords</span></a></li><li><a class="tocitem" href="#License"><span>License</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Part-1:-Loading-the-FMU"><span>Part 1: Loading the FMU</span></a></li><li><a class="tocitem" href="#Part-2:-Designing-the-Topology"><span>Part 2: Designing the Topology</span></a></li><li><a class="tocitem" href="#Part-3:-Training"><span>Part 3: Training</span></a></li><li><a class="tocitem" href="#Part-4:-Results-discussion"><span>Part 4: Results discussion</span></a></li></ul></li><li><a class="tocitem" href="../modelica_conference_2021/">Modelica Conference 2021</a></li><li><a class="tocitem" href="../workshops/">Pluto Workshops</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><a class="tocitem" href="../../library/">Library Functions</a></li><li><a class="tocitem" href="../../related/">Related Publication</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>MDPI 2022</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MDPI 2022</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ThummeTo/FMIFlux.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Physics-enhanced-NeuralODEs-in-real-world-applications"><a class="docs-heading-anchor" href="#Physics-enhanced-NeuralODEs-in-real-world-applications">Physics-enhanced NeuralODEs in real-world applications</a><a id="Physics-enhanced-NeuralODEs-in-real-world-applications-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-enhanced-NeuralODEs-in-real-world-applications" title="Permalink"></a></h1><p>Tutorial by <em>Tobias Thummerer</em> based on the paper <a href="https://doi.org/10.3390/electronics11193202"><em>NeuralFMU: presenting a workflow for integrating hybrid NeuralODEs into real-world applications</em></a></p><hr/><p>ðŸ“šðŸ“šðŸ“š This tutorial is archieved (so keeping it runnable is low priority), for a more up-to-date version see the <a href="https://github.com/ThummeTo/FMIFlux.jl/blob/examples/examples/src/juliacon_2023.ipynb">Workshop for JuliaCon2023</a> ðŸ“šðŸ“šðŸ“š</p><hr/><h2 id="Keywords"><a class="docs-heading-anchor" href="#Keywords">Keywords</a><a id="Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Keywords" title="Permalink"></a></h2><p>PeNODE, NeuralODE, Universal Differential Equation, Hybrid Modeling, Functional Mock-up Unit, FMU, NeuralFMU</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons
# Licensed under the MIT license. 
# See LICENSE (https://github.com/thummeto/FMIFlux.jl/blob/main/LICENSE) file in the project root for details.</code></pre><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>In this tutorial, a <em>vehicle longitudinal-dynamics model</em> (VLDM) as used in automotive industry, is extended to a NeuralFMU (PeNODE) to make better consumption predictions. You don&#39;t know what NeuralFMUs/PeNODEs are? No problem, this will be briefly explained during this tutorial, too.</p><p>This tutorial is a more easy, code-focussed version of the paper <a href="#Source">[1]</a>, if you find it useful for your work, please cite the linked paper. In this example, a real-world simulation model is enhanced in terms of accuracy using a so called <em>physics-enhanced neural ordinary differential equation</em> (PeNode). Basically, this is an extension to the NeuralODE concept and looks as can be seen in Fig. 1.</p><p><img src="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/img/mdpi_2022/neuralfmu.svg?raw=true" alt="NeuralFMU.svg"/></p><p><em>Fig.1: A possible representation for a physics-enhanced neural ordinary differential equation (PeNODE). An ODE model computes the system state derivative <span>$\dot{\vec{x}}$</span> based on a given system state <span>$\vec{x}$</span>, inputs <span>$\vec{u}$</span> and time <span>$t$</span>. The state derivative <span>$\dot{\vec{x}}$</span> is manipulated by the ANN into <span>$\hat{\dot{\vec{x}}}$</span> and finally integrated into the next system state <span>$\vec{x}(t+h)$</span>. PeNODEs that include FMUs instead of symbolic ODEs are called NeuralFMUs.</em></p><p>Note, that this is only one possible topology of a PeNODE, there could be an additional artifical neural network (ANN) before the ODE (that might share some connections with the other ANN). Further also other signals, like FMU state derivatives, inputs and outputs could be connected to the ANN(s). ODEs are in general not very handy, for modeling <strong>real</strong> applications, a more suitable container for ODEs is needed. The most common model exchange format in industry is the <em>Functional Mock-up interface</em> (FMI), models exported with FMI are called <em>Functional Mock-up unit</em> (FMU). Especially <em>model-exchange</em> FMUs can be seen as containers for ODEs. For more information, see (<a href="http://fmi-standard.org/">fmi-standard.org</a>). So if you want to use a real model from your modeling tool (with FMI support), you can simply export a FMU instead of handling large and bulky ODEs. If PeNODEs use FMUs instead of ODEs, they are called NeuralFMUs <a href="#Source">[2]</a>.</p><p>If that was a little bit fast, don&#39;t worry: This will be explained in detail later on.</p><h3 id="Formats"><a class="docs-heading-anchor" href="#Formats">Formats</a><a id="Formats-1"></a><a class="docs-heading-anchor-permalink" href="#Formats" title="Permalink"></a></h3><p>Besides, this <a href="https://github.com/ThummeTo/FMIFlux.jl/blob/examples/examples/mdpi_2022.ipynb">Jupyter Notebook</a> there is also a <a href="https://github.com/thummeto/FMIFlux.jl/blob/examples/examples/mdpi_2022.jl">Julia file</a> with the same name, which contains only the code cells. For the documentation there is a <a href="https://github.com/thummeto/FMIFlux.jl/blob/examples/examples/mdpi_2022.md">Markdown file</a> corresponding to the notebook.  </p><h3 id="Installation-prerequisites"><a class="docs-heading-anchor" href="#Installation-prerequisites">Installation prerequisites</a><a id="Installation-prerequisites-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-prerequisites" title="Permalink"></a></h3><table><tr><th style="text-align: left"></th><th style="text-align: left">Description</th><th style="text-align: left">Command</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: left">Enter Package Manager via</td><td style="text-align: left">]</td></tr><tr><td style="text-align: left">2.</td><td style="text-align: left">Install FMI via</td><td style="text-align: left">add FMI</td></tr><tr><td style="text-align: left">3.</td><td style="text-align: left">Install FMIFlux via</td><td style="text-align: left">add FMIFlux</td></tr><tr><td style="text-align: left">4.</td><td style="text-align: left">Install FMIZoo via</td><td style="text-align: left">add FMIZoo</td></tr><tr><td style="text-align: left">5.</td><td style="text-align: left">Install Plots via</td><td style="text-align: left">add Plots</td></tr><tr><td style="text-align: left">6.</td><td style="text-align: left">Install Random via</td><td style="text-align: left">add Random</td></tr><tr><td style="text-align: left">7.</td><td style="text-align: left">Install JLD2 via</td><td style="text-align: left">add JLD2</td></tr></table><h2 id="Part-1:-Loading-the-FMU"><a class="docs-heading-anchor" href="#Part-1:-Loading-the-FMU">Part 1: Loading the FMU</a><a id="Part-1:-Loading-the-FMU-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Loading-the-FMU" title="Permalink"></a></h2><p>To run the example, the previously installed packages must be included. </p><pre><code class="language-julia hljs"># Loading in the required libraries
using FMIFlux       # for NeuralFMUs
using FMI           # import FMUs into Julia 
using FMIZoo        # a collection of demo models, including the VLDM
using FMIFlux.Flux  # Machine Learning in Julia

import FMI.DifferentialEquations: Tsit5     # import the Tsit5-solver
import FMI: FMU2Solution
using JLD2                                  # data format for saving/loading parameters

# plotting
import Plots        # default plotting framework

# for interactive plotting
# import PlotlyJS     # plotting (interactive)
# Plots.plotlyjs()    # actiavte PlotlyJS as default plotting backend

# Let&#39;s fix the random seed to make our program determinsitic (ANN layers are initialized indeterminsitic otherwise)
import Random 
Random.seed!(1234)

# we use the Tsit5 solver for ODEs here 
solver = Tsit5();   </code></pre><p>Next, we load the FMU from the <em>FMIZoo.jl</em> and have a brief look on its metadata. For a more detailed view, see the <a href="https://github.com/ThummeTo/FMIZoo.jl/blob/main/models/src/VLDM.mo">Modelica model</a>.</p><pre><code class="language-julia hljs"># load our FMU (we take one from the FMIZoo.jl, exported with Dymola 2022x)
fmu = fmiLoad(&quot;VLDM&quot;, &quot;Dymola&quot;, &quot;2020x&quot;; type=:ME, logLevel=FMI.FMIImport.FMULogLevelInfo)  # `FMULogLevelInfo` = &quot;Log everything that might be interesting!&quot;, default is `FMULogLevelWarn`

# let&#39;s have a look on the model meta data
fmiInfo(fmu)</code></pre><p>As you can see, in section <em>States</em> there are six states listed:</p><table><tr><th style="text-align: left">ID</th><th style="text-align: left">Value Reference</th><th style="text-align: right">Value Name(s)</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">1</td><td style="text-align: left">33554432</td><td style="text-align: right">&quot;driver.accelerationPedalController.PI.x&quot;</td><td style="text-align: left">PI-Controller state (integrated error), accelerating</td></tr><tr><td style="text-align: left">2</td><td style="text-align: left">33554433</td><td style="text-align: right">&quot;driver.brakePedalController.PI.x&quot;</td><td style="text-align: left">PI-Controller state (integrated error), braking</td></tr><tr><td style="text-align: left">3</td><td style="text-align: left">33554434</td><td style="text-align: right">&quot;drivingCycle.s&quot;</td><td style="text-align: left">vehicle position (target)</td></tr><tr><td style="text-align: left">4</td><td style="text-align: left">33554435</td><td style="text-align: right">&quot;dynamics.accelerationCalculation.integrator.y&quot;</td><td style="text-align: left">vehicle position (actual)</td></tr><tr><td style="text-align: left">5</td><td style="text-align: left">33554436</td><td style="text-align: right">&quot;dynamics.accelerationCalculation.limiter.u&quot;, &quot;dynamics.accelerationCalculation.limIntegrator.y&quot;</td><td style="text-align: left">vehicle velocity (actual)</td></tr><tr><td style="text-align: left">6</td><td style="text-align: left">33554437</td><td style="text-align: right">&quot;result.integrator.y&quot;</td><td style="text-align: left">cumulative consumption * 3600</td></tr></table><p>Next thing is having a look on the real measurement data, that comes with the FMU. The VLDM and corresponding data are based on the <a href="https://github.com/TUMFTM/Component_Library_for_Full_Vehicle_Simulations">Component Library for Full Vehicle Simulations</a> <a href="#Source">[3]</a>.</p><pre><code class="language-julia hljs"># load data from FMIZoo.jl, gather simulation parameters for FMU
data = FMIZoo.VLDM(:train)
tStart = data.cumconsumption_t[1]
tStop = data.cumconsumption_t[end]
tSave = data.cumconsumption_t

# have a look on the FMU parameters (these are the file paths to the characteristic maps)
data.params</code></pre><p>Finally, we do a single simulation run and compare the simulation output to the real data.</p><pre><code class="language-julia hljs"># let&#39;s run a simulation from `tStart` to `tStop`, use the parameters we just viewed for the simulation run
resultFMU = fmiSimulate(fmu, (tStart, tStop); parameters=data.params) 
fig = fmiPlot(resultFMU)                                                                        # Plot it, but this is a bit too much, so ...
fig = fmiPlot(resultFMU; stateIndices=6:6)                                                      # ... only plot the state #6 and ...
fig = fmiPlot(resultFMU; stateIndices=6:6, ylabel=&quot;Cumulative consumption [Ws]&quot;, label=&quot;FMU&quot;)   # ... add some helpful labels!

# further plot the (measurement) data values `consumption_val` and deviation between measurements `consumption_dev`
Plots.plot!(fig, data.cumconsumption_t, data.cumconsumption_val; label=&quot;Data&quot;, ribbon=data.cumconsumption_dev, fillalpha=0.3)</code></pre><h2 id="Part-2:-Designing-the-Topology"><a class="docs-heading-anchor" href="#Part-2:-Designing-the-Topology">Part 2: Designing the Topology</a><a id="Part-2:-Designing-the-Topology-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2:-Designing-the-Topology" title="Permalink"></a></h2><p>After we have successful loaded the FMU, had a look inside its model description and simulated it, we want to build a hybrid model (NeuralFMU) with our FMU as its core. </p><h3 id="Part-2a:-Interfaces-between-ANNs-and-FMUs"><a class="docs-heading-anchor" href="#Part-2a:-Interfaces-between-ANNs-and-FMUs">Part 2a: Interfaces between ANNs and FMUs</a><a id="Part-2a:-Interfaces-between-ANNs-and-FMUs-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2a:-Interfaces-between-ANNs-and-FMUs" title="Permalink"></a></h3><p>What happens between ANNs and FMUs?</p><p>Note, that FMUs and ANNs don&#39;t operate within the same numerical ranges. Whereas FMU signals can basically use the entire range of a Float64, ANNs operate the best in a range that suits theire activation functions. Many activation functions saturate their input values. Consider the <span>$tanh$</span>-activation, that acts almost linear close around <span>$0$</span>, but drastically saturates values further away from zero:</p><pre><code class="language-julia hljs">for i in [0.0, 0.01, 0.1, 1.0, 10.0, 100.0, 1000.0]
    println(&quot;tanh($(i)) = $(tanh(i))&quot;)
end</code></pre><p>Similarly for the opposite direction: Signals from ANNs into FMUs may be too small, because of the limited output of the ANNs (or better: their activation functions). To prevent this issue, an appropriate transformation (like shifting and scaling) between ANNs and FMUs is necessary. In the following code section, the results of ignoring this is shown, together with a fix by using the provided <code>ScaleShift</code>- and <code>ShiftScale</code>-layers from <em>FMIFlux.jl</em>.</p><pre><code class="language-julia hljs"># variable we want to manipulate - why we are picking exactly these three is shown a few lines later ;-)
manipulatedDerVars = [&quot;der(dynamics.accelerationCalculation.integrator.y)&quot;,
                      &quot;der(dynamics.accelerationCalculation.limIntegrator.y)&quot;,
                      &quot;der(result.integrator.y)&quot;]
# alternative: manipulatedDerVars = fmu.modelDescription.derivativeValueReferences[4:6]

# reference simulation to record the derivatives 
resultFMU = fmiSimulate(fmu, (tStart, tStop), parameters=data.params, recordValues=:derivatives, saveat=tSave) 
vals = fmiGetSolutionValue(resultFMU, manipulatedDerVars)

# what happens without propper transformation between FMU- and ANN-domain?
Plots.plot(resultFMU.values.t, vals[1,:][1]; label=&quot;vehicle velocity&quot;);
Plots.plot!(resultFMU.values.t, tanh.(vals[1,:][1]); label=&quot;tanh(velocity)&quot;)

# setup shift/scale layers for pre-processing
preProcess = ShiftScale(vals)

# check what it&#39;s doing now ...
testVals = collect(preProcess(collect(val[t] for val in vals))[1] for t in 1:length(resultFMU.values.t))
Plots.plot(resultFMU.values.t, testVals; label=&quot;velocity (pre-processed)&quot;);
Plots.plot!(resultFMU.values.t, tanh.(testVals); label=&quot;tanh(velocity)&quot;)</code></pre><pre><code class="language-julia hljs"># add some additional &quot;buffer&quot;
preProcess.scale[:] *= 0.5 

# and check again what it&#39;s doing now ...
testVals = collect(preProcess(collect(val[t] for val in vals))[1] for t in 1:length(resultFMU.values.t))
Plots.plot(resultFMU.values.t, testVals; label=&quot;velocity (pre-processed)&quot;);
Plots.plot!(resultFMU.values.t, tanh.(testVals); label=&quot;tanh(velocity)&quot;)</code></pre><pre><code class="language-julia hljs"># ... also check the consumption
testVals = collect(preProcess(collect(val[t] for val in vals))[3] for t in 1:length(resultFMU.values.t))
Plots.plot(resultFMU.values.t, testVals; label=&quot;vehicle consumption (pre-processed)&quot;);
Plots.plot!(resultFMU.values.t, tanh.(testVals); label=&quot;tanh(consumption)&quot;)</code></pre><pre><code class="language-julia hljs"># setup scale/shift layer (inverse transformation) for post-processing
# we don&#39;t an inverse transform for the entire preProcess, only for the 2nd element (acceleration)
postProcess = ScaleShift(preProcess; indices=2:2)</code></pre><p>As a little extra, these shifting and scaling parameters are optimized together with the ANN parameters in the later training process!</p><h3 id="Part-2b:-ANN-in-and-output"><a class="docs-heading-anchor" href="#Part-2b:-ANN-in-and-output">Part 2b: ANN in- and output</a><a id="Part-2b:-ANN-in-and-output-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2b:-ANN-in-and-output" title="Permalink"></a></h3><p>Besides shifting and scaling, a major question is: What signals should be fed into the ANN and what signals should be output by it? We need to make some considerations:</p><ul><li><strong>What should be learned?</strong> In theory, we could manipulate every interface signal from and to the FMU, but in real life this is not efficient. The more signals we connect, the more partial derivatives need to be determined during training. So if there is something you know about the model (and often there is more than just <em>something</em>) you can use that knowledge to make your hybrid model more efficient. So ask yourself: <em>What</em> should be learned? And right after that: <em>How</em> could it be learned? In mechanical applications the answer will often be: A force (or momentum in rotational systems). Forces result in a change of acceleration, so they can be expressed by an additional acceleration. In mechanical systems, the acceleration is almost always a state derivative (the derivative of the velocity), so in many cases, manipulating the most differentiated state derivative - the acceleration - is a very good choice. </li><li><strong>How many ANNs do we need?</strong> Technically, you can add an arbitrary number of ANNs around your FMU (you can also use multiple FMUs if you want). But again, one should not use more than a single ANN if there is no good reason to do so. A second ANN <em>before</em> the FMU can be useful for example, if measurment offsets or similar effects should be corrected. Often, a single ANN to modify the state dynamics is sufficient.</li><li><strong>What signals from the FMU should be inserted into the ANN?</strong> In theory, we could use them all, meaning all states, state derivatives, time, inputs, outputs and other variables that are accessible through FMI. You know what comes next: Using less signals is the better choice, of course. If you know that the physical effect (here: the friction force), you have also an idea of what <em>influences</em> this effect or at least you know what values will have no impact and can be neglected to enhance training performance.</li></ul><p>At this specific example, the following considerations were made:</p><table><tr><th style="text-align: left"></th><th style="text-align: right">Consideration</th><th style="text-align: right">Considered inputs for the ANN</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: right">we have no system inputs, so <span>$\vec{u}=\{\}$</span>, nothing to add</td><td style="text-align: right"><span>$\{\}$</span></td></tr><tr><td style="text-align: left">2.</td><td style="text-align: right">we have no system outputs, so <span>$\vec{y}=\{\}$</span>, nothing to add</td><td style="text-align: right"><span>$\{\}$</span></td></tr><tr><td style="text-align: left">3.</td><td style="text-align: right">we know that the effect is not explicitly time-dependent on <span>$t$</span>, nothing to add</td><td style="text-align: right"><span>$\{\}$</span></td></tr><tr><td style="text-align: left">4.</td><td style="text-align: right">we have six states, that may influence the effect, add them</td><td style="text-align: right"><span>$\{x_1, x_2, x_3, x_4, x_5, x_6\}$</span></td></tr><tr><td style="text-align: left">5.</td><td style="text-align: right">we have six state derivatives, that may influence the effect, add them</td><td style="text-align: right"><span>$\{x_1, x_2, x_3, x_4, x_5, x_6\, \dot{x}_1, \dot{x}_2, \dot{x}_3, \dot{x}_4, \dot{x}_5, \dot{x}_6\}$</span></td></tr><tr><td style="text-align: left">6.</td><td style="text-align: right">the system is modelled as second order ODE, the state <span>$x_5$</span> (velocity) equlas the state derivative <span>$\dot{x}_4$</span>, remove <span>$x_5$</span></td><td style="text-align: right"><span>$\{x_1, x_2, x_3, x_4, x_6\, \dot{x}_1, \dot{x}_2, \dot{x}_3, \dot{x}_4, \dot{x}_5, \dot{x}_6\}$</span></td></tr><tr><td style="text-align: left">7.</td><td style="text-align: right">we know that the friction effect is not dependent on the driver controller, remove two states (<span>$x_1$</span> and <span>$x_2$</span>) and state derivatives (<span>$\dot{x}_1$</span> and <span>$\dot{x}_2$</span>)</td><td style="text-align: right"><span>$\{x_3, x_4, x_6\, \dot{x}_3, \dot{x}_4, \dot{x}_5, \dot{x}_6\}$</span></td></tr><tr><td style="text-align: left">8.</td><td style="text-align: right">we know that the friction effect is not dependent on the target driving cycle position <span>$x_3$</span> or velocity <span>$\dot{x}_3$</span>, remove them</td><td style="text-align: right"><span>$\{x_4, x_6\, \dot{x}_4, \dot{x}_5, \dot{x}_6\}$</span></td></tr><tr><td style="text-align: left">9.</td><td style="text-align: right">we assume that the friction effect is not dependent on the vehicle position <span>$x_4$</span>, remove <span>$x_4$</span></td><td style="text-align: right"><span>$\{x_6\, \dot{x}_4, \dot{x}_5, \dot{x}_6\}$</span></td></tr><tr><td style="text-align: left">10.</td><td style="text-align: right">we assume that the friction effect is not dependent on the accumulated vehicle consumption <span>$x_6$</span>, remove <span>$x_6$</span></td><td style="text-align: right"><span>$\{\dot{x}_4, \dot{x}_5, \dot{x}_6\}$</span></td></tr></table><p>These considerations lead to the following topology:</p><p><img src="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/img/mdpi_2022/usedneuralfmu.svg?raw=true" alt="usedneuralfmu.svg"/></p><p><em>Fig.2: The used topology for a NeuralFMU in this example. The ANN operates based on the signals <span>$\dot{x}_4, \dot{x}_5, \dot{x}_6$</span> from the FMU, but only modifies the signal <span>$\hat{\dot{x}}_5$</span>. The gates <span>$p_{FMU}$</span> and <span>$p_{ANN}$</span> control how much the dynamics of FMU and ANN contribute to the NeuralFMU dynamics. Starting with <span>$p_{FMU}=1.0$</span> and <span>$p_{ANN}=0.0$</span> makes an initialization routine obsolete, because the dynamics of the NeuralFMU equal the dynamics of the FMU, see <a href="#Source">[1]</a> for further details.</em></p><h3 id="Part-2c:-Translating-topology-to-Julia"><a class="docs-heading-anchor" href="#Part-2c:-Translating-topology-to-Julia">Part 2c: Translating topology to Julia</a><a id="Part-2c:-Translating-topology-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2c:-Translating-topology-to-Julia" title="Permalink"></a></h3><p>To implement the signal bypass in a layer sequence, two layers named <code>CacheLayer</code> and <code>CacheRetrieveLayer</code> are used to cache and retrieve arbitrary values:</p><pre><code class="language-julia hljs"># setup cache layers 
cache = CacheLayer()
cacheRetrieve = CacheRetrieveLayer(cache)

gates = ScaleSum([1.0, 0.0]) # signal from FMU (#1 = 1.0), signal from ANN (#2 = 0.0)

# setup the NeuralFMU topology
net = Chain(x -&gt; fmu(; x=x, dx_refs=:all),      # take `x`, put it into the FMU, retrieve all `dx`
            dx -&gt; cache(dx),                    # cache `dx`
            dx -&gt; dx[4:6],                      # forward only dx[4, 5, 6]
            preProcess,                         # pre-process `dx`
            Dense(3, 32, tanh),                 # Dense Layer 3 -&gt; 32 with `tanh` activasion
            Dense(32, 1, tanh),                 # Dense Layer 32 -&gt; 1 with `tanh` activasion 
            postProcess,                        # post process `dx`
            dx -&gt; cacheRetrieve(5:5, dx),       # dynamics FMU | dynamics ANN
            gates,                              # compute resulting dx from ANN + FMU
            dx -&gt; cacheRetrieve(1:4, dx, 6:6))  # stack together: dx[1,2,3,4] from cache + dx from ANN + dx[6] from cache

# build NeuralFMU
neuralFMU = ME_NeuralFMU(fmu, net, (tStart, tStop), solver; saveat=tSave)
neuralFMU.modifiedState = false # speed optimization (no ANN before the FMU)

# get start state vector from data (FMIZoo)
x0 = FMIZoo.getStateVector(data, tStart)

# simulate and plot the (uninitialized) NeuralFMU
resultNFMU_original = neuralFMU(x0, (tStart, tStop); parameters=data.params, showProgress=true) 
fig = fmiPlot(resultNFMU_original; stateIndices=5:5, label=&quot;NeuralFMU (original)&quot;, ylabel=&quot;velocity [m/s]&quot;)

# plot the original FMU and data
fmiPlot!(fig, resultFMU; stateIndices=5:5, values=false)
Plots.plot!(fig, data.speed_t, data.speed_val, label=&quot;Data&quot;)</code></pre><p>As to expect, all trajectories overlap.</p><h3 id="Part-2d:-Initialization"><a class="docs-heading-anchor" href="#Part-2d:-Initialization">Part 2d: Initialization</a><a id="Part-2d:-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2d:-Initialization" title="Permalink"></a></h3><p>In general, initialization of (phyiscs-enhanced) NeuralODEs is challenging, because ANNs are initialized random by default. In this case we are using a special initialization method introducing two gates, that control how much of the original FMU dynamics and how much of the ANN dynamics is introduced to the final model dynamics. See the paper <a href="#Source">[1]</a> for a deeper insight.</p><h2 id="Part-3:-Training"><a class="docs-heading-anchor" href="#Part-3:-Training">Part 3: Training</a><a id="Part-3:-Training-1"></a><a class="docs-heading-anchor-permalink" href="#Part-3:-Training" title="Permalink"></a></h2><p>Finally: The actual training!</p><p>Basically, you can use your custom loss function, batching strategies and optimsation routines with <em>FMIFlux.jl</em>. Because we need to keep it short here, we use some tools already shipped with <em>FMIFlux.jl</em>.</p><pre><code class="language-julia hljs"># prepare training data (array of arrays required)
train_data = collect([d] for d in data.cumconsumption_val)
train_t = data.cumconsumption_t 

# switch to a more efficient execution configuration, allocate only a single FMU instance, see:
# https://thummeto.github.io/FMI.jl/dev/features/#Execution-Configuration
fmu.executionConfig = FMI.FMIImport.FMU2_EXECUTION_CONFIGURATION_NOTHING
c, _ = FMIFlux.prepareSolveFMU(neuralFMU.fmu, nothing, neuralFMU.fmu.type, true, false, false, false, true, data.params; x0=x0)

# batch the data (time, targets), train only on model output index 6, plot batch elements
batch = batchDataSolution(neuralFMU, t -&gt; FMIZoo.getStateVector(data, t), train_t, train_data;
    batchDuration=10.0, indicesModel=6:6, plot=false, parameters=data.params, showProgress=false) # try `plot=true` to show the batch elements, try `showProgress=true` to display simulation progress

# limit the maximum number of solver steps to 1e5 and maximum simulation/training duration to 30 minutes
solverKwargsTrain = Dict{Symbol, Any}(:maxiters =&gt; 1e5, :max_execution_duration =&gt; 10.0*60.0)

# picks a modified MSE, which weights the last time point MSE with 25% and the remaining element MSE with 75%
# this promotes training a continuous function, even when training on batch elements
function lossFct(solution::FMU2Solution)
    ts = dataIndexForTime(solution.states.t[1])
    te = dataIndexForTime(solution.states.t[end])

    a = fmiGetSolutionState(solution, 6; isIndex=true)
    b = train_data[ts:te]
    return FMIFlux.Losses.mse_last_element_rel(a, b, 0.5)
end

# initialize a &quot;worst error growth scheduler&quot; (updates all batch losses, pick the batch element with largest error increase)
# apply the scheduler after every training step, plot the current status every 25 steps and update all batch element losses every 5 steps
scheduler = LossAccumulationScheduler(neuralFMU, batch, lossFct; applyStep=1, plotStep=25, updateStep=5)
updateScheduler = () -&gt; update!(scheduler)

# defines a loss for the entire batch (accumulate error of batch elements)
batch_loss = p -&gt; FMIFlux.Losses.batch_loss(neuralFMU, batch; 
    showProgress=false, p=p, parameters=data.params, update=true, lossFct=lossFct, logLoss=true, solverKwargsTrain...) # try `showProgress=true` to display simulation progress

# loss for training, take element from the worst element scheduler
loss = p -&gt; FMIFlux.Losses.loss(neuralFMU, batch; 
    showProgress=false, p=p, parameters=data.params, lossFct=lossFct, batchIndex=scheduler.elementIndex, logLoss=false, solverKwargsTrain...) # try `showProgress=true` to display simulation progress

# we start with a slightly opended ANN gate (1%) and a almost completely opened FMU gate (99%)
gates.scale[:] = [0.99, 0.01] 

# gather the parameters from the NeuralFMU
params = FMIFlux.params(neuralFMU)

params[1][end-1] = 0.99
params[1][end] = 0.01

# for training, we use the Adam optimizer with step size 1e-3
optim = Adam(1e-3) 

# let&#39;s check the loss we are starting with ...
loss_before = batch_loss(params[1])

# initialize the scheduler 
initialize!(scheduler; parameters=data.params, p=params[1], showProgress=false)</code></pre><p>Finally, the lines we are waiting for so long:</p><pre><code class="language-julia hljs">batchLen = length(batch)

# we use ForwardDiff for gradinet determination, because the FMU throws multiple events per time instant (this is not supported by reverse mode AD)
# the chunk_size controls the nuber of forward evaluations of the model (the bigger, the less evaluations)
FMIFlux.train!(loss, neuralFMU, Iterators.repeated((), batchLen), optim; gradient=:ForwardDiff, chunk_size=32, cb=updateScheduler) 
loss_after = batch_loss(params[1])</code></pre><p>The batch loss (&quot;AVG&quot; and &quot;MAX&quot;) is only updated every 5 steps, as defined in the scheduler. Every 25 steps, we plot the current batch element losses. Please note, that we only did around 100 training steps, so training has not converged for now. But we are curious and want to have a look on the intermediate results. </p><p>After training, it seems a good idea to store the optimized parameters for later use:</p><pre><code class="language-julia hljs"># save the parameters (so we can use them tomorrow again)
paramsPath = joinpath(@__DIR__, &quot;params_$(scheduler.step)steps.jld2&quot;)
fmiSaveParameters(neuralFMU, paramsPath)

# switch back to the default execution configuration, see:
# https://thummeto.github.io/FMI.jl/dev/features/#Execution-Configuration
fmu.executionConfig = FMI.FMIImport.FMU2_EXECUTION_CONFIGURATION_NO_RESET
FMIFlux.finishSolveFMU(neuralFMU.fmu, c, false, true)</code></pre><p>The loss has decreased, but the final question is: Are we better? This can be easily checked by running a simulation and compare it to the training data:</p><pre><code class="language-julia hljs"># check what had been learned by the NeuralFMU, simulate it ...
resultNFMU_train = neuralFMU(x0, (tStart, tStop); parameters=data.params, showProgress=true, recordValues=manipulatedDerVars, maxiters=1e7) # [120s]

# Load parameters 
fmiLoadParameters(neuralFMU, paramsPath)

# are we better?
mse_NFMU = FMIFlux.Losses.mse(data.cumconsumption_val, fmiGetSolutionState(resultNFMU_train, 6; isIndex=true))
mse_FMU  = FMIFlux.Losses.mse(data.cumconsumption_val, fmiGetSolutionState(resultFMU, 6; isIndex=true))

# ... and plot it
fig = fmiPlot(resultNFMU_train; stateIndices=6:6, values=false, stateEvents=false, label=&quot;NeuralFMU&quot;, title=&quot;Training Data&quot;);
fmiPlot!(fig, resultFMU; stateIndices=6:6, stateEvents=false, values=false, label=&quot;FMU&quot;);
Plots.plot!(fig, train_t, data.cumconsumption_val, label=&quot;Data&quot;, ribbon=data.cumconsumption_dev, fillalpha=0.3)</code></pre><h2 id="Part-4:-Results-discussion"><a class="docs-heading-anchor" href="#Part-4:-Results-discussion">Part 4: Results discussion</a><a id="Part-4:-Results-discussion-1"></a><a class="docs-heading-anchor-permalink" href="#Part-4:-Results-discussion" title="Permalink"></a></h2><p><strong>WIP: coming soon!</strong></p><pre><code class="language-julia hljs"># clean-up
fmiUnload(fmu) </code></pre><h3 id="Source"><a class="docs-heading-anchor" href="#Source">Source</a><a id="Source-1"></a><a class="docs-heading-anchor-permalink" href="#Source" title="Permalink"></a></h3><p>[1] Tobias Thummerer, Johannes Stoljar and Lars Mikelsons. 2022. <strong>NeuralFMU: presenting a workflow for integrating hybrid NeuralODEs into real-world applications.</strong> Electronics 11, 19, 3202. <a href="https://doi.org/10.3390/electronics11193202">DOI: 10.3390/electronics11193202</a></p><p>[2] Tobias Thummerer, Lars Mikelsons and Josef Kircher. 2021. <strong>NeuralFMU: towards structural integration of FMUs into neural networks.</strong> Martin SjÃ¶lund, Lena Buffoni, Adrian Pop and Lennart Ochel (Ed.). Proceedings of 14th Modelica Conference 2021, LinkÃ¶ping, Sweden, September 20-24, 2021. LinkÃ¶ping University Electronic Press, LinkÃ¶ping (LinkÃ¶ping Electronic Conference Proceedings ; 181), 297-306. <a href="https://doi.org/10.3384/ecp21181297">DOI: 10.3384/ecp21181297</a></p><p>[3] Danquah, B.; Koch, A.; Weis, T.; Lienkamp, M.; Pinnel, A. 2019. <strong>Modular, Open Source Simulation Approach: Application to Design and Analyze Electric Vehicles.</strong> In Proceedings of the IEEE 2019 Fourteenth International Conference on Ecological Vehicles and Renewable Energies (EVER), Monte Carlo, Monaco, 8â€“10 May 2019; pp. 1â€“8. <a href="https://doi.org/10.1109/EVER.2019.8813568">DOI: 10.1109/EVER.2019.8813568</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../juliacon_2023/">Â« JuliaCon 2023</a><a class="docs-footer-nextpage" href="../modelica_conference_2021/">Modelica Conference 2021 Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Friday 19 April 2024 12:20">Friday 19 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
