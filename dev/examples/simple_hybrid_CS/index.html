<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simple CS-NeuralFMU · FMIFlux.jl</title><meta name="title" content="Simple CS-NeuralFMU · FMIFlux.jl"/><meta property="og:title" content="Simple CS-NeuralFMU · FMIFlux.jl"/><meta property="twitter:title" content="Simple CS-NeuralFMU · FMIFlux.jl"/><meta name="description" content="Documentation for FMIFlux.jl."/><meta property="og:description" content="Documentation for FMIFlux.jl."/><meta property="twitter:description" content="Documentation for FMIFlux.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FMIFlux.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Simple CS-NeuralFMU</a><ul class="internal"><li><a class="tocitem" href="#License"><span>License</span></a></li><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Introduction-to-the-example"><span>Introduction to the example</span></a></li><li><a class="tocitem" href="#Target-group"><span>Target group</span></a></li><li><a class="tocitem" href="#Other-formats"><span>Other formats</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Code-section"><span>Code section</span></a></li><li><a class="tocitem" href="#CS-NeuralFMU"><span>CS-NeuralFMU</span></a></li></ul></li><li><a class="tocitem" href="../simple_hybrid_ME/">Simple ME-NeuralFMU</a></li><li><a class="tocitem" href="../growing_horizon_ME/">Growing Horizon ME-NeuralFMU</a></li><li><a class="tocitem" href="../juliacon_2023/">JuliaCon 2023</a></li><li><a class="tocitem" href="../mdpi_2022/">MDPI 2022</a></li><li><a class="tocitem" href="../modelica_conference_2021/">Modelica Conference 2021</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><a class="tocitem" href="../../library/">Library Functions</a></li><li><a class="tocitem" href="../../related/">Related Publication</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Simple CS-NeuralFMU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simple CS-NeuralFMU</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ThummeTo/FMIFlux.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Creation-and-training-of-CS-NeuralFMUs"><a class="docs-heading-anchor" href="#Creation-and-training-of-CS-NeuralFMUs">Creation and training of CS-NeuralFMUs</a><a id="Creation-and-training-of-CS-NeuralFMUs-1"></a><a class="docs-heading-anchor-permalink" href="#Creation-and-training-of-CS-NeuralFMUs" title="Permalink"></a></h1><p>Tutorial by Johannes Stoljar, Tobias Thummerer</p><p>Last edit: 15.11.2023</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Johannes Stoljar
# Licensed under the MIT license. 
# See LICENSE (https://github.com/thummeto/FMIFlux.jl/blob/main/LICENSE) file in the project root for details.</code></pre><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>The Julia Package <em>FMIFlux.jl</em> is motivated by the application of hybrid modeling. This package enables the user to integrate his simulation model between neural networks (NeuralFMU). For this, the simulation model must be exported as FMU (functional mock-up unit), which corresponds to a widely used standard. The big advantage of hybrid modeling with artificial neural networks is, that effects that are difficult to model (because they might be unknown) can be easily learned by the neural networks. For this purpose, the NeuralFMU is trained with measurement data containing the not modeled physical effect. The final product is a simulation model including the originally not modeled effects. Another big advantage of the NeuralFMU is that it works with little data, because the FMU already contains the characteristic functionality of the simulation and only the missing effects are added.</p><p>NeuralFMUs do not need to be as easy as in this example. Basically a NeuralFMU can combine different ANN topologies that manipulate any FMU-input (system state, system inputs, time) and any FMU-output (system state derivative, system outputs, other system variables). However, for this example a NeuralFMU topology as shown in the following picture is used.</p><p><img src="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/img/CSNeuralFMU.svg?raw=true" alt="CS-NeuralFMU.svg"/></p><p><em>NeuralFMU (CS) from</em> <a href="#Source">[1]</a>.</p><h2 id="Introduction-to-the-example"><a class="docs-heading-anchor" href="#Introduction-to-the-example">Introduction to the example</a><a id="Introduction-to-the-example-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-the-example" title="Permalink"></a></h2><p>In this example, the model of a one-dimensional spring pendulum (with an external acting force) is used to learn the initial states. For this purpose, on the one hand the initial position of the mass of the pendulum is shifted and on the other hand the default position of the mass from the model is used. The model with the shifted initial position serves as reference and is called <em>referenceFMU</em> in the following. The model with the default position is further referenced with <em>defaultFMU</em>. At the beginning, the actual state of both simulations is shown, whereby clear deviations can be seen in the graphs. Afterwards, the <em>defaultFMU</em> is integrated into a co-simulation NeuralFMU (CS-NeuralFMU) architecture. By training the NeuralFMU, an attempt is made to learn the initial displacement of the <em>referenceFMU</em>. It can be clearly seen that the NeuralFMU learns this shift well in just a few training steps. </p><h2 id="Target-group"><a class="docs-heading-anchor" href="#Target-group">Target group</a><a id="Target-group-1"></a><a class="docs-heading-anchor-permalink" href="#Target-group" title="Permalink"></a></h2><p>The example is primarily intended for users who work in the field of first principle and/or hybrid modeling and are further interested in hybrid model building. The example wants to show how simple it is to combine FMUs with machine learning and to illustrate the advantages of this approach.</p><h2 id="Other-formats"><a class="docs-heading-anchor" href="#Other-formats">Other formats</a><a id="Other-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Other-formats" title="Permalink"></a></h2><p>Besides, this <a href="https://github.com/thummeto/FMIFlux.jl/blob/examples/examples/src/simple_hybrid_CS.ipynb">Jupyter Notebook</a> there is also a <a href="https://github.com/thummeto/FMIFlux.jl/blob/examples/examples/src/simple_hybrid_CS.jl">Julia file</a> with the same name, which contains only the code cells and for the documentation there is a <a href="https://github.com/thummeto/FMIFlux.jl/blob/examples/examples/src/simple_hybrid_CS.md">Markdown file</a> corresponding to the notebook.  </p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><h3 id="Installation-prerequisites"><a class="docs-heading-anchor" href="#Installation-prerequisites">Installation prerequisites</a><a id="Installation-prerequisites-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-prerequisites" title="Permalink"></a></h3><table><tr><th style="text-align: left"></th><th style="text-align: left">Description</th><th style="text-align: left">Command</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: left">Enter Package Manager via</td><td style="text-align: left">]</td></tr><tr><td style="text-align: left">2.</td><td style="text-align: left">Install FMI via</td><td style="text-align: left">add FMI</td></tr><tr><td style="text-align: left">3.</td><td style="text-align: left">Install FMIFlux via</td><td style="text-align: left">add FMIFlux</td></tr><tr><td style="text-align: left">4.</td><td style="text-align: left">Install FMIZoo via</td><td style="text-align: left">add FMIZoo</td></tr><tr><td style="text-align: left">5.</td><td style="text-align: left">Install DifferentialEquations via</td><td style="text-align: left">add DifferentialEquations</td></tr><tr><td style="text-align: left">6.</td><td style="text-align: left">Install Plots via</td><td style="text-align: left">add Plots</td></tr><tr><td style="text-align: left">7.</td><td style="text-align: left">Install Random via</td><td style="text-align: left">add Random</td></tr></table><h2 id="Code-section"><a class="docs-heading-anchor" href="#Code-section">Code section</a><a id="Code-section-1"></a><a class="docs-heading-anchor-permalink" href="#Code-section" title="Permalink"></a></h2><p>To run the example, the previously installed packages must be included. </p><pre><code class="language-julia hljs"># imports
using FMI
using FMIFlux
using FMIFlux.Flux
using FMIZoo
using DifferentialEquations: Tsit5
import Plots

# set seed
import Random
Random.seed!(1234);</code></pre><pre><code class="nohighlight hljs">[33m[1m┌ [22m[39m[33m[1mWarning: [22m[39mError requiring `Enzyme` from `LinearSolve`
[33m[1m│ [22m[39m  exception =
[33m[1m│ [22m[39m   LoadError: ArgumentError: Package LinearSolve does not have Enzyme in its dependencies:
[33m[1m│ [22m[39m   - You may have a partially installed environment. Try `Pkg.instantiate()`
[33m[1m│ [22m[39m     to ensure all packages in the environment are installed.
[33m[1m│ [22m[39m   - Or, if you have LinearSolve checked out for development and have
[33m[1m│ [22m[39m     added Enzyme as a dependency but haven&#39;t updated your primary
[33m[1m│ [22m[39m     environment&#39;s manifest file, try `Pkg.resolve()`.
[33m[1m│ [22m[39m   - Otherwise you may need to report an issue with LinearSolve
[33m[1m│ [22m[39m   Stacktrace:
[33m[1m│ [22m[39m     [1] [0m[1mmacro expansion[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4mloading.jl:1167[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m     [2] [0m[1mmacro expansion[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4mlock.jl:223[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m     [3] [0m[1mrequire[22m[0m[1m([22m[90minto[39m::[0mModule, [90mmod[39m::[0mSymbol[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:1144[24m[39m
[33m[1m│ [22m[39m     [4] [0m[1minclude[22m[0m[1m([22m[90mmod[39m::[0mModule, [90m_path[39m::[0mString[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mBase.jl:419[24m[39m
[33m[1m│ [22m[39m     [5] [0m[1minclude[22m[0m[1m([22m[90mx[39m::[0mString[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[35mLinearSolve[39m [90mC:\Users\runneradmin\.julia\packages\LinearSolve\qCLK7\src\[39m[90m[4mLinearSolve.jl:1[24m[39m
[33m[1m│ [22m[39m     [6] [0m[1mmacro expansion[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mC:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\[39m[90m[4mRequires.jl:40[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m     [7] top-level scope
[33m[1m│ [22m[39m   [90m    @ [39m[90mC:\Users\runneradmin\.julia\packages\LinearSolve\qCLK7\src\[39m[90m[4minit.jl:16[24m[39m
[33m[1m│ [22m[39m     [8] [0m[1meval[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4mboot.jl:368[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m     [9] [0m[1meval[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mC:\Users\runneradmin\.julia\packages\LinearSolve\qCLK7\src\[39m[90m[4mLinearSolve.jl:1[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [10] [0m[1m(::LinearSolve.var&quot;#88#97&quot;)[22m[0m[1m([22m[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[35mLinearSolve[39m [90mC:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\[39m[90m[4mrequire.jl:101[24m[39m
[33m[1m│ [22m[39m    [11] [0m[1mmacro expansion[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m[4mtiming.jl:382[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [12] [0m[1merr[22m[0m[1m([22m[90mf[39m::[0mAny, [90mlistener[39m::[0mModule, [90mmodname[39m::[0mString, [90mfile[39m::[0mString, [90mline[39m::[0mAny[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[36mRequires[39m [90mC:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\[39m[90m[4mrequire.jl:47[24m[39m
[33m[1m│ [22m[39m    [13] [0m[1m(::LinearSolve.var&quot;#87#96&quot;)[22m[0m[1m([22m[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[35mLinearSolve[39m [90mC:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\[39m[90m[4mrequire.jl:100[24m[39m
[33m[1m│ [22m[39m    [14] [0m[1mwithpath[22m[0m[1m([22m[90mf[39m::[0mAny, [90mpath[39m::[0mString[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[36mRequires[39m [90mC:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\[39m[90m[4mrequire.jl:37[24m[39m
[33m[1m│ [22m[39m    [15] [0m[1m(::LinearSolve.var&quot;#86#95&quot;)[22m[0m[1m([22m[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[35mLinearSolve[39m [90mC:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\[39m[90m[4mrequire.jl:99[24m[39m
[33m[1m│ [22m[39m    [16] [0m[1m#invokelatest#2[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4messentials.jl:729[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [17] [0m[1minvokelatest[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4messentials.jl:726[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [18] [0m[1mforeach[22m[0m[1m([22m[90mf[39m::[0mtypeof(Base.invokelatest), [90mitr[39m::[0mVector[90m{Function}[39m[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mabstractarray.jl:2774[24m[39m
[33m[1m│ [22m[39m    [19] [0m[1mloadpkg[22m[0m[1m([22m[90mpkg[39m::[0mBase.PkgId[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[36mRequires[39m [90mC:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\[39m[90m[4mrequire.jl:27[24m[39m
[33m[1m│ [22m[39m    [20] [0m[1m#invokelatest#2[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4messentials.jl:729[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [21] [0m[1minvokelatest[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4messentials.jl:726[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [22] [0m[1mrun_package_callbacks[22m[0m[1m([22m[90mmodkey[39m::[0mBase.PkgId[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:869[24m[39m
[33m[1m│ [22m[39m    [23] [0m[1m_tryrequire_from_serialized[22m[0m[1m([22m[90mmodkey[39m::[0mBase.PkgId, [90mpath[39m::[0mString, [90msourcepath[39m::[0mString, [90mdepmods[39m::[0mVector[90m{Any}[39m[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:944[24m[39m
[33m[1m│ [22m[39m    [24] [0m[1m_require_search_from_serialized[22m[0m[1m([22m[90mpkg[39m::[0mBase.PkgId, [90msourcepath[39m::[0mString, [90mbuild_id[39m::[0mUInt64[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:1028[24m[39m
[33m[1m│ [22m[39m    [25] [0m[1m_require[22m[0m[1m([22m[90mpkg[39m::[0mBase.PkgId[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:1315[24m[39m
[33m[1m│ [22m[39m    [26] [0m[1m_require_prelocked[22m[0m[1m([22m[90muuidkey[39m::[0mBase.PkgId[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:1200[24m[39m
[33m[1m│ [22m[39m    [27] [0m[1mmacro expansion[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4mloading.jl:1180[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [28] [0m[1mmacro expansion[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4mlock.jl:223[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [29] [0m[1mrequire[22m[0m[1m([22m[90minto[39m::[0mModule, [90mmod[39m::[0mSymbol[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:1144[24m[39m
[33m[1m│ [22m[39m    [30] [0m[1meval[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4mboot.jl:368[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [31] [0m[1minclude_string[22m[0m[1m([22m[90mmapexpr[39m::[0mtypeof(REPL.softscope), [90mmod[39m::[0mModule, [90mcode[39m::[0mString, [90mfilename[39m::[0mString[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90mBase[39m [90m.\[39m[90m[4mloading.jl:1428[24m[39m
[33m[1m│ [22m[39m    [32] [0m[1msoftscope_include_string[22m[0m[1m([22m[90mm[39m::[0mModule, [90mcode[39m::[0mString, [90mfilename[39m::[0mString[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[32mSoftGlobalScope[39m [90mC:\Users\runneradmin\.julia\packages\SoftGlobalScope\u4UzH\src\[39m[90m[4mSoftGlobalScope.jl:65[24m[39m
[33m[1m│ [22m[39m    [33] [0m[1mexecute_request[22m[0m[1m([22m[90msocket[39m::[0mZMQ.Socket, [90mmsg[39m::[0mIJulia.Msg[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[33mIJulia[39m [90mC:\Users\runneradmin\.julia\packages\IJulia\Vo51o\src\[39m[90m[4mexecute_request.jl:67[24m[39m
[33m[1m│ [22m[39m    [34] [0m[1m#invokelatest#2[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4messentials.jl:729[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [35] [0m[1minvokelatest[22m
[33m[1m│ [22m[39m   [90m    @ [39m[90m.\[39m[90m[4messentials.jl:726[24m[39m[90m [inlined][39m
[33m[1m│ [22m[39m    [36] [0m[1meventloop[22m[0m[1m([22m[90msocket[39m::[0mZMQ.Socket[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[33mIJulia[39m [90mC:\Users\runneradmin\.julia\packages\IJulia\Vo51o\src\[39m[90m[4meventloop.jl:8[24m[39m
[33m[1m│ [22m[39m    [37] [0m[1m(::IJulia.var&quot;#15#18&quot;)[22m[0m[1m([22m[0m[1m)[22m
[33m[1m│ [22m[39m   [90m    @ [39m[33mIJulia[39m [90m.\[39m[90m[4mtask.jl:484[24m[39m
[33m[1m│ [22m[39m   in expression starting at C:\Users\runneradmin\.julia\packages\LinearSolve\qCLK7\ext\LinearSolveEnzymeExt.jl:1
[33m[1m└ [22m[39m[90m@ Requires C:\Users\runneradmin\.julia\packages\Requires\Z8rfN\src\require.jl:51[39m</code></pre><p>After importing the packages, the path to the <em>Functional Mock-up Units</em> (FMUs) is set. The FMU is a model exported meeting the <em>Functional Mock-up Interface</em> (FMI) Standard. The FMI is a free standard (<a href="http://fmi-standard.org/">fmi-standard.org</a>) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. </p><p>The objec-orientated structure of the <em>SpringPendulumExtForce1D</em> can be seen in the following graphic. This model is a simple spring pendulum without friction, but with an external force. </p><p><img src="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/img/SpringPendulumExtForce1D.svg?raw=true" alt="svg"/></p><p>Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.</p><pre><code class="language-julia hljs">tStart = 0.0
tStep = 0.01
tStop = 5.0
tSave = tStart:tStep:tStop</code></pre><pre><code class="nohighlight hljs">0.0:0.01:5.0</code></pre><h3 id="ReferenceFMU"><a class="docs-heading-anchor" href="#ReferenceFMU">ReferenceFMU</a><a id="ReferenceFMU-1"></a><a class="docs-heading-anchor-permalink" href="#ReferenceFMU" title="Permalink"></a></h3><p>In the next lines of code the FMU of the <em>referenceFMU</em> model is loaded from <em>FMIZoo.jl</em> and the information about the FMU is shown.  </p><pre><code class="language-julia hljs">referenceFMU = fmiLoad(&quot;SpringPendulumExtForce1D&quot;, &quot;Dymola&quot;, &quot;2022x&quot;)
fmiInfo(referenceFMU)</code></pre><pre><code class="nohighlight hljs">#################### Begin information for FMU ####################
	Model name:			SpringPendulumExtForce1D
	FMI-Version:			2.0
	GUID:				{df5ebe46-3c86-42a5-a68a-7d008395a7a3}
	Generation tool:		Dymola Version 2022x (64-bit), 2021-10-08
	Generation time:		2022-05-19T06:54:33Z
	Var. naming conv.:		structured
	Event indicators:		0
	Inputs:				1
		352321536 [&quot;extForce&quot;]
	Outputs:			2
		335544320 [&quot;accSensor.v&quot;, &quot;der(accSensor.flange.s)&quot;, &quot;v&quot;, &quot;der(speedSensor.flange.s)&quot;, &quot;speedSensor.v&quot;]
		335544321 [&quot;der(accSensor.v)&quot;, &quot;a&quot;, &quot;accSensor.a&quot;]
	States:				2
		33554432 [&quot;mass.s&quot;]
		33554433 [&quot;mass.v&quot;]
	Supports Co-Simulation:		true
		Model identifier:	SpringPendulumExtForce1D
		Get/Set State:		true
		Serialize State:	true
		Dir. Derivatives:	true
		Var. com. steps:	true
		Input interpol.:	true
		Max order out. der.:	1
	Supports Model-Exchange:	true
		Model identifier:	SpringPendulumExtForce1D
		Get/Set State:		true
		Serialize State:	true
		Dir. Derivatives:	true
##################### End information for FMU #####################</code></pre><p>In the next steps the parameters are defined. The first parameter is the initial position of the mass, which is initilized with <span>$1.3𝑚$</span>. The second parameter is the initial velocity of the mass, which is initilized with <span>$0\frac{m}{s}$</span>. The FMU hase two states: The first state is the position of the mass and the second state is the velocity. In the function fmiSimulate() the <em>referenceFMU</em> is simulated, still specifying the start and end time, the parameters and which variables are recorded. After the simulation is finished the result of the <em>referenceFMU</em> can be plotted. This plot also serves as a reference for the later CS-NeuralFMU model.</p><pre><code class="language-julia hljs">param = Dict(&quot;mass_s0&quot; =&gt; 1.3, &quot;mass.v&quot; =&gt; 0.0)   # increase amplitude, invert phase
vrs = [&quot;mass.s&quot;, &quot;mass.v&quot;, &quot;mass.a&quot;]
referenceSimData = fmiSimulate(referenceFMU, (tStart, tStop); parameters=param, recordValues=vrs, saveat=tSave)
fmiPlot(referenceSimData)</code></pre><pre><code class="nohighlight hljs">[34mSimulating CS-FMU ...   0%|█                             |  ETA: N/A[39m

[34mSimulating CS-FMU ... 100%|██████████████████████████████| Time: 0:00:02[39m</code></pre><p><img src="../simple_hybrid_CS_files/simple_hybrid_CS_11_2.svg" alt="svg"/></p><p>The data from the simulation of the <em>referenceFMU</em>, are divided into position, velocity and acceleration data. The data for the acceleration will be needed later. </p><pre><code class="language-julia hljs">posReference = fmi2GetSolutionValue(referenceSimData, vrs[1])
velReference = fmi2GetSolutionValue(referenceSimData, vrs[2])
accReference = fmi2GetSolutionValue(referenceSimData, vrs[3])</code></pre><pre><code class="nohighlight hljs">501-element Vector{Float64}:
 -1.9999999999999996
 -1.9988827275812904
 -1.9958127258179004
 -1.9907908533763607
 -1.9837918439669844
 -1.9748258342855118
 -1.963890162864621
 -1.9510089134488018
 -1.9361810148909009
 -1.9194099484303728
 -1.9007374108186537
 -1.8801634598739092
 -1.8576990114645708
  ⋮
  1.9971927754348462
  2.0126501310664713
  2.026070116129912
  2.037424725618772
  2.0467236772128947
  2.0541004250985972
  2.0594240680173828
  2.062679095787284
  2.0638499982263325
  2.0629212651525553
  2.059877386383986
  2.0548550901379925</code></pre><h3 id="DefaultFMU"><a class="docs-heading-anchor" href="#DefaultFMU">DefaultFMU</a><a id="DefaultFMU-1"></a><a class="docs-heading-anchor-permalink" href="#DefaultFMU" title="Permalink"></a></h3><p>The following is a renaming for the <em>referenceFMU</em> to <em>defaultFMU</em>. The previous initial position of the mass is now set to the default position of the <em>defaultFMU</em>. The initial position of the mass is initilized with <span>$0.5𝑚$</span> and initial velocity of the mass is initialized with <span>$0\frac{m}{s}$</span>.</p><pre><code class="language-julia hljs">defaultFMU = referenceFMU
param = Dict(&quot;mass_s0&quot; =&gt; 0.5, &quot;mass.v&quot; =&gt; 0.0)</code></pre><pre><code class="nohighlight hljs">Dict{String, Float64} with 2 entries:
  &quot;mass_s0&quot; =&gt; 0.5
  &quot;mass.v&quot;  =&gt; 0.0</code></pre><p>The following simulate and plot the <em>defaultFMU</em> just like the <em>referenceFMU</em>. The differences between both systems can be clearly seen from the plots. In the plots for the <em>defaultFMU</em> you can see that other oscillations occur due to the different starting positions. On the one hand the oscillation of the <em>defaultFMU</em> starts in the opposite direction of the <em>referenceFMU</em> and on the other hand the graphs for the velocity and acceleration differ clearly in the amplitude. In the following we try to learn the initial shift of the position so that the graphs for the acceleration of both graphs match.</p><pre><code class="language-julia hljs">defaultSimData = fmiSimulate(defaultFMU, (tStart, tStop); parameters=param, recordValues=vrs, saveat=tSave)
fmiPlot(defaultSimData)</code></pre><p><img src="../simple_hybrid_CS_files/simple_hybrid_CS_17_0.svg" alt="svg"/></p><p>The data from the simualtion of the <em>defaultFMU</em>, are divided into position, velocity and acceleration data. The data for the acceleration will be needed later.</p><pre><code class="language-julia hljs">posDefault = fmi2GetSolutionValue(defaultSimData, vrs[1])
velDefault = fmi2GetSolutionValue(defaultSimData, vrs[2])
accDefault = fmi2GetSolutionValue(defaultSimData, vrs[3])</code></pre><pre><code class="nohighlight hljs">501-element Vector{Float64}:
  6.0
  5.996872980925033
  5.987824566254761
  5.9728274953129645
  5.95187583433241
  5.9249872805026715
  5.892169834645022
  5.853465119227542
  5.808892969264781
  5.75851573503067
  5.702370188387734
  5.640527685538739
  5.573049035471661
  ⋮
 -5.842615646003006
 -5.884869953422783
 -5.921224800662572
 -5.9516502108284985
 -5.976144547672481
 -5.994659284032171
 -6.007174453690571
 -6.013675684067705
 -6.014154196220591
 -6.008606804843264
 -5.997055285530499
 -5.979508813705998</code></pre><h2 id="CS-NeuralFMU"><a class="docs-heading-anchor" href="#CS-NeuralFMU">CS-NeuralFMU</a><a id="CS-NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#CS-NeuralFMU" title="Permalink"></a></h2><p>In this section, the <em>defaultFMU</em> is inserted into a CS-NeuralFMU architecture. It has the goal to learn the initial state of the <em>referenceFMU</em>.</p><p>For the external force, a simple function is implemented that always returns a force of <span>$0N$</span> at each time point. Also, all other functions and implementations would be possible here. Only for simplification reasons the function was chosen so simply.</p><pre><code class="language-julia hljs">function extForce(t)
    return [0.0]
end </code></pre><pre><code class="nohighlight hljs">extForce (generic function with 1 method)</code></pre><h4 id="Loss-function"><a class="docs-heading-anchor" href="#Loss-function">Loss function</a><a id="Loss-function-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-function" title="Permalink"></a></h4><p>In order to train our model, a loss function must be implemented. The solver of the NeuralFMU can calculate the gradient of the loss function. The gradient descent is needed to adjust the weights in the neural network so that the sum of the error is reduced and the model becomes more accurate.</p><p>The loss function in this implementation consists of the mean squared error (mse) from the acceleration data of the <em>referenceFMU</em> simulation (<code>accReference</code>) and the acceleration data of the network (<code>accNet</code>).</p><p class="math-container">\[e_{mse} = \frac{1}{n} \sum\limits_{i=0}^n (accReference[i] - accNet[i])^2\]</p><pre><code class="language-julia hljs"># loss function for training
function lossSum(p)
    solution = csNeuralFMU(extForce, tStep, (tStart, tStop); p=p) # saveat=tSave

    accNet = fmi2GetSolutionValue(solution, 2; isIndex=true)
    
    FMIFlux.Losses.mse(accReference, accNet)
end</code></pre><pre><code class="nohighlight hljs">lossSum (generic function with 1 method)</code></pre><h4 id="Callback"><a class="docs-heading-anchor" href="#Callback">Callback</a><a id="Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Callback" title="Permalink"></a></h4><p>To output the loss in certain time intervals, a callback is implemented as a function in the following. Here a counter is incremented, every twentieth pass the loss function is called and the average error is printed out.</p><pre><code class="language-julia hljs"># callback function for training
global counter = 0
function callb(p)
    global counter += 1

    if counter % 25 == 1
        avgLoss = lossSum(p[1])
        @info &quot;Loss [$counter]: $(round(avgLoss, digits=5))&quot;
    end
end</code></pre><pre><code class="nohighlight hljs">callb (generic function with 1 method)</code></pre><h4 id="Structure-of-the-CS-NeuralFMU"><a class="docs-heading-anchor" href="#Structure-of-the-CS-NeuralFMU">Structure of the CS-NeuralFMU</a><a id="Structure-of-the-CS-NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-the-CS-NeuralFMU" title="Permalink"></a></h4><p>In the following, the topology of the CS-NeuralFMU is constructed. It consists of an input layer, which then leads into the <em>defaultFMU</em> model. The CS-FMU computes the outputs for the given system state and time step. After the <em>defaultFMU</em> follows a dense layer, which has exactly as many inputs as the model has outputs. The output of this layer consists of 16 output nodes and a <em>tanh</em> activation function. The next layer has 16 input and output nodes with the same activation function. The last layer is again a dense layer with 16 input nodes and the number of model outputs as output nodes. Here, it is important that no <em>tanh</em>-activation function follows, because otherwise the pendulums state values would be limited to the interval <span>$[-1;1]$</span>.</p><pre><code class="language-julia hljs"># check outputs
outputs = defaultFMU.modelDescription.outputValueReferences 
numOutputs = length(outputs)
display(outputs)

# check inputs
inputs = defaultFMU.modelDescription.inputValueReferences 
numInputs = length(inputs)
display(inputs)

# NeuralFMU setup
net = Chain(u -&gt; defaultFMU(;u_refs=inputs, u=u, y_refs=outputs),
            Dense(numOutputs, 16, tanh),
            Dense(16, 16, tanh),
            Dense(16, numOutputs))</code></pre><pre><code class="nohighlight hljs">2-element Vector{UInt32}:
 0x14000000
 0x14000001



1-element Vector{UInt32}:
 0x15000000





Chain(
  var&quot;#1#2&quot;(),
  Dense(2 =&gt; 16, tanh),                 [90m# 48 parameters[39m
  Dense(16 =&gt; 16, tanh),                [90m# 272 parameters[39m
  Dense(16 =&gt; 2),                       [90m# 34 parameters[39m
) [90m                  # Total: 6 arrays, [39m354 parameters, 1.758 KiB.</code></pre><h4 id="Definition-of-the-CS-NeuralFMU"><a class="docs-heading-anchor" href="#Definition-of-the-CS-NeuralFMU">Definition of the CS-NeuralFMU</a><a id="Definition-of-the-CS-NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-CS-NeuralFMU" title="Permalink"></a></h4><p>The instantiation of the CS-NeuralFMU is done as a one-liner. The FMU <code>defaultFMU</code>, the structure of the network <code>net</code>, start <code>tStart</code> and end time <code>tStop</code>, and the time steps <code>tSave</code> for saving are specified.</p><pre><code class="language-julia hljs">csNeuralFMU = CS_NeuralFMU(defaultFMU, net, (tStart, tStop));</code></pre><h4 id="Plot-before-training"><a class="docs-heading-anchor" href="#Plot-before-training">Plot before training</a><a id="Plot-before-training-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-before-training" title="Permalink"></a></h4><p>Here the state trajectory of the <em>extForceFMU</em> is recorded. Doesn&#39;t really look like a pendulum yet, but the system is random initialized by default. In the plots later on, the effect of learning can be seen.</p><pre><code class="language-julia hljs">solutionBefore = csNeuralFMU(extForce, tStep, (tStart, tStop)) # ; saveat=tSave
accNeuralFMU = fmi2GetSolutionValue(solutionBefore, 1; isIndex=true)
Plots.plot(tSave, accNeuralFMU, label=&quot;acc CS-NeuralFMU&quot;, linewidth=2)</code></pre><p><img src="../simple_hybrid_CS_files/simple_hybrid_CS_32_0.svg" alt="svg"/></p><h4 id="Training-of-the-CS-NeuralFMU"><a class="docs-heading-anchor" href="#Training-of-the-CS-NeuralFMU">Training of the CS-NeuralFMU</a><a id="Training-of-the-CS-NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#Training-of-the-CS-NeuralFMU" title="Permalink"></a></h4><p>For the training of the CS-NeuralFMU the parameters are extracted. The known Adam optimizer for minimizing the gradient descent is used as further passing parameters. In addition, the previously defined loss and callback function, as well as the number of epochs are passed.</p><pre><code class="language-julia hljs"># train
paramsNet = FMIFlux.params(csNeuralFMU)

optim = Adam()
FMIFlux.train!(lossSum, csNeuralFMU, Iterators.repeated((), 250), optim; cb=()-&gt;callb(paramsNet))</code></pre><pre><code class="nohighlight hljs">[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [1]: 2.37052
[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [26]: 0.30045


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [51]: 0.04673


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [76]: 0.03035


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [101]: 0.0182


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [126]: 0.01046


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [151]: 0.00573


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [176]: 0.00305


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [201]: 0.00164


[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mLoss [226]: 0.00092</code></pre><h4 id="Comparison-of-the-plots"><a class="docs-heading-anchor" href="#Comparison-of-the-plots">Comparison of the plots</a><a id="Comparison-of-the-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-the-plots" title="Permalink"></a></h4><p>Here three plots are compared with each other and only the acceleration of the mass is considered. The first plot presents the <em>defaultFMU</em>, the second the <em>referenceFMU</em> and the third plot the result after training the CS-NeuralFMU. </p><pre><code class="language-julia hljs"># plot results mass.a
solutionAfter = csNeuralFMU(extForce, tStep, (tStart, tStop)) # saveat=tSave, p=paramsNet[1]

fig = Plots.plot(xlabel=&quot;t [s]&quot;, ylabel=&quot;mass acceleration [m/s^2]&quot;, linewidth=2,
                 xtickfontsize=12, ytickfontsize=12,
                 xguidefontsize=12, yguidefontsize=12,
                 legendfontsize=8, legend=:topright)

accNeuralFMU = fmi2GetSolutionValue(solutionAfter, 2; isIndex=true)

Plots.plot!(fig, tSave, accDefault, label=&quot;defaultFMU&quot;, linewidth=2)
Plots.plot!(fig, tSave, accReference, label=&quot;referenceFMU&quot;, linewidth=2)
Plots.plot!(fig, tSave, accNeuralFMU, label=&quot;CS-NeuralFMU (1000 eps.)&quot;, linewidth=2)
fig </code></pre><p><img src="../simple_hybrid_CS_files/simple_hybrid_CS_36_0.svg" alt="svg"/></p><p>Finally, the FMU is cleaned-up.</p><pre><code class="language-julia hljs">fmiUnload(defaultFMU)</code></pre><h3 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h3><p>Based on the plots, it can be clearly seen that the CS-NeuralFMU model is able to learn the shift of the initial position. Even after only 1000 training steps, the curves overlap very much, so no further training with more runs is needed.</p><h3 id="Source"><a class="docs-heading-anchor" href="#Source">Source</a><a id="Source-1"></a><a class="docs-heading-anchor-permalink" href="#Source" title="Permalink"></a></h3><p>[1] Tobias Thummerer, Lars Mikelsons and Josef Kircher. 2021. <strong>NeuralFMU: towards structural integration of FMUs into neural networks.</strong> Martin Sjölund, Lena Buffoni, Adrian Pop and Lennart Ochel (Ed.). Proceedings of 14th Modelica Conference 2021, Linköping, Sweden, September 20-24, 2021. Linköping University Electronic Press, Linköping (Linköping Electronic Conference Proceedings ; 181), 297-306. <a href="https://doi.org/10.3384/ecp21181297">DOI: 10.3384/ecp21181297</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../simple_hybrid_ME/">Simple ME-NeuralFMU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 21 February 2024 16:26">Wednesday 21 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
