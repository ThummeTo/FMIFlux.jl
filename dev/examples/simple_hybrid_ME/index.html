<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simple ME-NeuralFMU · FMIFlux.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FMIFlux.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Examples Overview</a></li><li><a class="tocitem" href="../simple_hybrid_CS/">Simple CS-NeuralFMU</a></li><li class="is-active"><a class="tocitem" href>Simple ME-NeuralFMU</a><ul class="internal"><li><a class="tocitem" href="#License"><span>License</span></a></li><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Introduction-to-the-example"><span>Introduction to the example</span></a></li><li><a class="tocitem" href="#Target-group"><span>Target group</span></a></li><li><a class="tocitem" href="#Other-formats"><span>Other formats</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Code-section"><span>Code section</span></a></li><li><a class="tocitem" href="#NeuralFMU"><span>NeuralFMU</span></a></li></ul></li><li><a class="tocitem" href="../modelica_conference_2021/">Modelica Conference 2021</a></li></ul></li><li><a class="tocitem" href="../../library/overview/">Library Functions</a></li><li><a class="tocitem" href="../../related/">Related Publication</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Simple ME-NeuralFMU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simple ME-NeuralFMU</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ThummeTo/FMIFlux.jl/blob/master/docs/src/examples/simple_hybrid_ME.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Creation-and-training-of-ME-NeuralFMUs"><a class="docs-heading-anchor" href="#Creation-and-training-of-ME-NeuralFMUs">Creation and training of ME-NeuralFMUs</a><a id="Creation-and-training-of-ME-NeuralFMUs-1"></a><a class="docs-heading-anchor-permalink" href="#Creation-and-training-of-ME-NeuralFMUs" title="Permalink"></a></h1><p>Tutorial by Johannes Stoljar, Tobias Thummerer</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><p>Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Johannes Stoljar</p><p>Licensed under the MIT license. See <a href="https://github.com/thummeto/FMIFlux.jl/blob/main/LICENSE">LICENSE</a> file in the project root for details.</p><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>This Julia Package is motivated by the application of hybrid modeling. This package enables the user to integrate his simulation model between neural networks (NeuralFMU). For this, the simulation model must be exported as FMU (functional mock-up unit), which corresponds to a widely used standard. The big advantage of hybrid modeling with artificial neural networks is, that effects that are difficult to model (because they might be unknown) can be easily learned by the neural networks. For this purpose, the NeuralFMU is trained with measurement data containing the unmodeled physical effect. The final product is a simulation model including the orignially unmodeled effects. Another big advantage of the NeuralFMU is that it works with little data, because the FMU already contains the characterisitic functionality of the simulation and only the missing effects are added.</p><p>NeuralFMUs need not to be as easy as in this example. Basically a NeuralFMU can combine different ANN topologies that manipulate any FMU-input (system state, system inputs, time) and any FMU-output (system state derivative, system outputs, other system variables). However, for this example a NeuralFMU topology as shown in the following picture is used.</p><p><img src="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/pics/NeuralFMU.svg?raw=true" alt="NeuralFMU.svg"/></p><p><em>NeuralFMU (ME) from</em> <a href="#Source">[1]</a>.</p><h2 id="Introduction-to-the-example"><a class="docs-heading-anchor" href="#Introduction-to-the-example">Introduction to the example</a><a id="Introduction-to-the-example-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-the-example" title="Permalink"></a></h2><p>In this example, simplified modeling of a one-dimensional spring pendulum (without friction) is compared to a model of the same system that includes a nonlinear friction model. The FMU with the simplified model will be named <em>simpleFMU</em> in the following and the model with the friction will be named <em>realFMU</em>. At the beginning, the actual state of both simulations is shown, whereby clear deviations can be seen in the graphs. The <em>realFMU</em> serves as a reference graph. The <em>simpleFMU</em> is then integrated into a NeuralFMU architecture and a training of the entire network is performed. After the training the final state is compared again to the <em>realFMU</em>. It can be clearly seen that by using the NeuralFMU, learning of the friction process has taken place.  </p><h2 id="Target-group"><a class="docs-heading-anchor" href="#Target-group">Target group</a><a id="Target-group-1"></a><a class="docs-heading-anchor-permalink" href="#Target-group" title="Permalink"></a></h2><p>The example is primarily intended for users who work in the field of first principle and/or hybrid modeling and are further interested in hybrid model building. The example wants to show how simple it is to combine FMUs with machine learning and to illustrate the advantages of this approach.</p><h2 id="Other-formats"><a class="docs-heading-anchor" href="#Other-formats">Other formats</a><a id="Other-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Other-formats" title="Permalink"></a></h2><p>Besides this <a href="https://github.com/thummeto/FMIFlux.jl/blob/main/example/simple_hybrid_ME.ipynb">Jupyter Notebook</a> there is also a <a href="https://github.com/thummeto/FMIFlux.jl/blob/main/example/simple_hybrid_ME.jl">Julia file</a> with the same name, which contains only the code cells and for the documentation there is a <a href="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/simple_hybrid_ME.md">Markdown file</a> corresponding to the notebook.  </p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><h3 id="Installation-prerequisites"><a class="docs-heading-anchor" href="#Installation-prerequisites">Installation prerequisites</a><a id="Installation-prerequisites-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-prerequisites" title="Permalink"></a></h3><table><tr><th style="text-align: left"></th><th style="text-align: left">Description</th><th style="text-align: left">Command</th><th style="text-align: left">Alternative</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: left">Enter Package Manager via</td><td style="text-align: left">]</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">2.</td><td style="text-align: left">Install FMI via</td><td style="text-align: left">add FMI</td><td style="text-align: left">add &quot; https://github.com/ThummeTo/FMI.jl &quot;</td></tr><tr><td style="text-align: left">3.</td><td style="text-align: left">Install FMIFlux via</td><td style="text-align: left">add FMIFlux</td><td style="text-align: left">add &quot; https://github.com/ThummeTo/FMIFlux.jl &quot;</td></tr><tr><td style="text-align: left">4.</td><td style="text-align: left">Install Flux via</td><td style="text-align: left">add Flux</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">5.</td><td style="text-align: left">Install DifferentialEquations via</td><td style="text-align: left">add DifferentialEquations</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">6.</td><td style="text-align: left">Install Plots via</td><td style="text-align: left">add Plots</td><td style="text-align: left"></td></tr></table><h2 id="Code-section"><a class="docs-heading-anchor" href="#Code-section">Code section</a><a id="Code-section-1"></a><a class="docs-heading-anchor-permalink" href="#Code-section" title="Permalink"></a></h2><p>To run the example, the previously installed packages must be included. </p><pre><code class="language-julia"># imports
using FMI
using FMIFlux
using Flux
using DifferentialEquations: Tsit5
import Plots</code></pre><p>After importing the packages, the path to the <em>Functional Mock-up Units</em> (FMUs) is set. The FMU is a model exported meeting the <em>Functional Mock-up Interface</em> (FMI) Standard. The FMI is a free standard (<a href="http://fmi-standard.org/">fmi-standard.org</a>) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. </p><p>The objec-orientated structure of the <em>SpringPendulum1D</em> (<em>simpleFMU</em>) can be seen in the following graphic and corresponds to a simple modeling.</p><p><img src="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/pics/SpringPendulum1D.svg?raw=true" alt="svg"/></p><p>In contrast, the model <em>SpringFrictionPendulum1D</em> (<em>realFMU</em>) is somewhat more accurate, because it includes a friction component. </p><p><img src="https://github.com/thummeto/FMIFlux.jl/blob/main/docs/src/examples/pics/SpringFrictionPendulum1D.svg?raw=true" alt="svg"/></p><p>Here the path for the <a href="https://github.com/thummeto/FMIFlux.jl/blob/main/model/SpringPendulum1D.fmu"><em>SpringPendulum1D</em></a> and the <a href="https://github.com/thummeto/FMIFlux.jl/blob/main/model/SpringFrictionPendulum1D.fmu"><em>SpringFrictionPendulum1D</em></a> model is set: </p><pre><code class="language-julia">simpleFMUPath = joinpath(dirname(@__FILE__), &quot;../model/SpringPendulum1D.fmu&quot;)
realFMUPath = joinpath(dirname(@__FILE__), &quot;../model/SpringFrictionPendulum1D.fmu&quot;)
println(&quot;SimpleFMU path: &quot;, simpleFMUPath)
println(&quot;RealFMU path: &quot;, realFMUPath)</code></pre><pre><code class="language-none">SimpleFMU path: ../model/SpringPendulum1D.fmu
RealFMU path: ../model/SpringFrictionPendulum1D.fmu</code></pre><p>Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.</p><pre><code class="language-julia">tStart = 0.0
tStep = 0.01
tStop = 5.0
tSave = collect(tStart:tStep:tStop)</code></pre><pre><code class="language-none">501-element Vector{Float64}:
 0.0
 0.01
 0.02
 0.03
 0.04
 0.05
 0.06
 0.07
 0.08
 0.09
 0.1
 0.11
 0.12
 ⋮
 4.89
 4.9
 4.91
 4.92
 4.93
 4.94
 4.95
 4.96
 4.97
 4.98
 4.99
 5.0</code></pre><h3 id="RealFMU"><a class="docs-heading-anchor" href="#RealFMU">RealFMU</a><a id="RealFMU-1"></a><a class="docs-heading-anchor-permalink" href="#RealFMU" title="Permalink"></a></h3><p>In the next lines of code the FMU of the <em>realFMU</em> model is loaded and instantiated.  </p><pre><code class="language-julia">realFMU = fmiLoad(realFMUPath)
fmiInstantiate!(realFMU; loggingOn=false)
fmiInfo(realFMU)</code></pre><pre><code class="language-none">┌ Info: fmi2Unzip(...): Successfully unzipped 28 files at `C:\Users\JOHANN~1\AppData\Local\Temp\fmijl_xMsNGp\SpringFrictionPendulum1D`.
└ @ FMI C:\Users\Johannes Stoljar\.julia\packages\FMI\l4qPg\src\FMI2.jl:273
┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.
└ @ FMI C:\Users\Johannes Stoljar\.julia\packages\FMI\l4qPg\src\FMI2.jl:376


#################### Begin information for FMU ####################
	Model name:			SpringFrictionPendulum1D
	FMI-Version:			2.0
	GUID:				{b02421b8-652a-4d48-9ffc-c2b223aa1b94}
	Generation tool:		Dymola Version 2020x (64-bit), 2019-10-10
	Generation time:		2021-11-23T13:36:30Z
	Var. naming conv.:		structured
	Event indicators:		24
	Inputs:				0
	Outputs:			0
	States:				2


┌ Info: fmi2Load(...): FMU resources location is `file:///C:/Users/JOHANN~1/AppData/Local/Temp/fmijl_xMsNGp/SpringFrictionPendulum1D/resources`
└ @ FMI C:\Users\Johannes Stoljar\.julia\packages\FMI\l4qPg\src\FMI2.jl:384


		33554432 [&quot;mass.s&quot;]
		33554433 [&quot;mass.v&quot;, &quot;mass.v_relfric&quot;]
	Supports Co-Simulation:		true
		Model identifier:	SpringFrictionPendulum1D
		Get/Set State:		true
		Serialize State:	true
		Dir. Derivatives:	true
		Var. com. steps:	true
		Input interpol.:	true
		Max order out. der.:	1
	Supports Model-Exchange:	true
		Model identifier:	SpringFrictionPendulum1D
		Get/Set State:		true
		Serialize State:	true
		Dir. Derivatives:	true
##################### End information for FMU #####################</code></pre><p>Both the start and end time are set via the <em>fmiSetupExperiment()</em> function. The experiment is initialized to get the information of the continuous states. You can get all continuous states of a FMU by the function <em>fmiGetContinuousStates()</em> and this is also done for the <em>realFMU</em>. It has two states: The first state is the position of the mass, which is initilized with <span>$0.5m$</span>, the second state is the velocity, which is initialized with <span>$0\frac{m}{s}$</span>.   </p><pre><code class="language-julia">fmiSetupExperiment(realFMU, tStart, tStop)

fmiEnterInitializationMode(realFMU)
fmiExitInitializationMode(realFMU)

x₀ = fmiGetContinuousStates(realFMU)</code></pre><pre><code class="language-none">2-element Vector{Float64}:
 0.5
 0.0</code></pre><p>In the following code block the <em>realFMU</em> is simulated, still specifying which variables are included. After the simulation is finished the result of the <em>realFMU</em> can be plotted. This plot also serves as a reference for the other model (<em>simpleFMU</em>).</p><pre><code class="language-julia">vrs = [&quot;mass.s&quot;, &quot;mass.v&quot;, &quot;mass.a&quot;, &quot;mass.f&quot;]
_, realSimData = fmiSimulate(realFMU, tStart, tStop; recordValues=vrs, saveat=tSave, setup=false, reset=false)
fmiPlot(realFMU, vrs, realSimData)</code></pre><p><img src="../simple_hybrid_ME_files/simple_hybrid_ME_12_0.svg" alt="svg"/></p><p>After the plots are created, the FMU is unloaded.</p><pre><code class="language-julia">fmiUnload(realFMU)</code></pre><p>The data from the simualtion of the <em>realFMU</em>, are divided into position and velocity data. These data will be needed later. </p><pre><code class="language-julia">velReal = collect(data[2] for data in realSimData.saveval)
posReal = collect(data[1] for data in realSimData.saveval)</code></pre><pre><code class="language-none">501-element Vector{Float64}:
 0.5
 0.5002147350958549
 0.5008572068150906
 0.5019307343013393
 0.5034377791759037
 0.5053797361931734
 0.507757421354132
 0.5105710760625108
 0.5138202661486302
 0.5175035429290001
 0.5216187663581402
 0.5261643784845171
 0.5311361825547609
 ⋮
 1.0618338496933084
 1.0629441718413108
 1.0639256972572486
 1.0647763670106132
 1.06549412855799
 1.0660771282511987
 1.066523587371857
 1.066831801521633
 1.0670001400125004
 1.0670339828286313
 1.0670339828276312
 1.067033982826631</code></pre><h3 id="SimpleFMU"><a class="docs-heading-anchor" href="#SimpleFMU">SimpleFMU</a><a id="SimpleFMU-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleFMU" title="Permalink"></a></h3><p>The following lines load, instantiate, simulate and plot the <em>simpleFMU</em> just like the <em>realFMU</em>. The differences between both systems can be clearly seen from the plots. In the plot for the <em>realFMU</em> it can be seen that the oscillation continues to decrease due to the effect of the friction. If you would simulate long enough, the oscillation would come to a standstill in a certain time. The oscillation in the <em>simpleFMU</em> behaves differently, since the friction was not taken into account here. The oscillation in this model would continue to infinity with the same oscillation amplitude. From this observation the desire of an improvement of this model arises.     </p><pre><code class="language-julia">simpleFMU = fmiLoad(simpleFMUPath)

fmiInstantiate!(simpleFMU; loggingOn=false)
fmiInfo(simpleFMU)

vrs = [&quot;mass.s&quot;, &quot;mass.v&quot;, &quot;mass.a&quot;]
_, simpleSimData = fmiSimulate(simpleFMU, tStart, tStop; recordValues=vrs, saveat=tSave, reset=false)
fmiPlot(simpleFMU, vrs, simpleSimData)</code></pre><pre><code class="language-none">┌ Info: fmi2Unzip(...): Successfully unzipped 28 files at `C:\Users\JOHANN~1\AppData\Local\Temp\fmijl_waNZuu\SpringPendulum1D`.
└ @ FMI C:\Users\Johannes Stoljar\.julia\packages\FMI\l4qPg\src\FMI2.jl:273


#################### Begin information for FMU ####################
	Model name:			SpringPendulum1D
	FMI-Version:			2.0
	GUID:				{5030e5a4-87c0-42cf-8779-74ebea1906aa}
	Generation tool:		Dymola Version 2020x (64-bit), 2019-10-10
	Generation time:		2021-07-21T05:28:53Z
	Var. naming conv.:		structured
	Event indicators:		0
	Inputs:				0
	Outputs:			0
	States:				2
		33554432 [&quot;mass.s&quot;]
		33554433 [&quot;mass.v&quot;]
	Supports Co-Simulation:		true
		Model identifier:	SpringPendulum1D
		Get/Set State:		true
		Serialize State:	true
		Dir. Derivatives:	true
		Var. com. steps:	true
		Input interpol.:	true
		Max order out. der.:	1
	Supports Model-Exchange:	true
		Model identifier:	SpringPendulum1D
		Get/Set State:		true
		Serialize State:	true
		Dir. Derivatives:	true
##################### End information for FMU #####################

┌ Info: fmi2Load(...): FMU supports both CS and ME, using CS as default if nothing specified.
└ @ FMI C:\Users\Johannes Stoljar\.julia\packages\FMI\l4qPg\src\FMI2.jl:376
┌ Info: fmi2Load(...): FMU resources location is `file:///C:/Users/JOHANN~1/AppData/Local/Temp/fmijl_waNZuu/SpringPendulum1D/resources`
└ @ FMI C:\Users\Johannes Stoljar\.julia\packages\FMI\l4qPg\src\FMI2.jl:384</code></pre><p><img src="../simple_hybrid_ME_files/simple_hybrid_ME_18_4.svg" alt="svg"/></p><p>The data from the simualtion of the <em>simpleFMU</em>, are divided into position and velocity data. These data will be needed later to plot the results. </p><pre><code class="language-julia">velSimple = collect(data[2] for data in simpleSimData.saveval)
posSimple = collect(data[1] for data in simpleSimData.saveval)</code></pre><pre><code class="language-none">501-element Vector{Float64}:
 0.5
 0.5003017486819993
 0.5012013738965729
 0.5026995396955733
 0.5047948922822549
 0.5074848828353776
 0.5107669098963398
 0.5146380970115599
 0.5190939866425227
 0.5241313516074874
 0.5297437685244978
 0.5359273025527665
 0.5426739933868466
 ⋮
 1.6817454106640481
 1.6860262621029507
 1.6897211631373532
 1.6928264987575015
 1.6953392775960465
 1.6972564609104965
 1.698576276381512
 1.6992975610979462
 1.6994196580640215
 1.6989425410415007
 1.6978667510389276
 1.6961926527257059</code></pre><h2 id="NeuralFMU"><a class="docs-heading-anchor" href="#NeuralFMU">NeuralFMU</a><a id="NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#NeuralFMU" title="Permalink"></a></h2><h4 id="Loss-function"><a class="docs-heading-anchor" href="#Loss-function">Loss function</a><a id="Loss-function-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-function" title="Permalink"></a></h4><p>In order to train our model, a loss function must be implemented. The solver of the NeuralFMU can calculate the gradient of the loss function. The gradient descent is needed to adjust the weights in the neural network so that the sum of the error is reduced and the model becomes more accurate.</p><p>The loss function in this implmentation consists of the mean squared error (mse) from the real position of the <em>realFMU</em> simulation (posReal) and the position data of the network (posNet). $ mse = \frac{1}{n} \sum\limits_{i=0}^n (posReal[i] - posNet[i])^2 $</p><p>As it is indicated with the comments, one could also additionally consider the mse from the real velocity (velReal) and the velocity from the network (velNet). The error in this case would be calculated from the sum of both errors.</p><pre><code class="language-julia"># loss function for training
function lossSum()
    solution = neuralFMU(x₀, tStart)

    posNet = collect(data[1] for data in solution.u)
    #velNet = collect(data[2] for data in solution.u)

    Flux.Losses.mse(posReal, posNet) #+ Flux.Losses.mse(velReal, velNet)
end</code></pre><pre><code class="language-none">lossSum (generic function with 1 method)</code></pre><h4 id="Callback"><a class="docs-heading-anchor" href="#Callback">Callback</a><a id="Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Callback" title="Permalink"></a></h4><p>To output the loss in certain time intervals, a callback is implemented as a function in the following. Here a counter is incremented, every twentieth pass the loss function is called and the average error is printed out.</p><pre><code class="language-julia"># callback function for training
global counter = 0
function callb()
    global counter += 1

    if counter % 20 == 1
        avgLoss = lossSum()
        @info &quot;Loss [$counter]: $(round(avgLoss, digits=5))   Avg displacement in data: $(round(sqrt(avgLoss), digits=5))&quot;
    end
end</code></pre><pre><code class="language-none">callb (generic function with 1 method)</code></pre><h4 id="Structure-of-the-NeuralFMU"><a class="docs-heading-anchor" href="#Structure-of-the-NeuralFMU">Structure of the NeuralFMU</a><a id="Structure-of-the-NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-the-NeuralFMU" title="Permalink"></a></h4><p>In the following, the topology of the NeuralFMU is constructed. It consists of an input layer, which then leads into the <em>simpleFMU</em> model. The ME-FMU computes the state derivatives for a given system state. Following the <em>simpleFMU</em> is a dense layer that has exactly as many inputs as the model has states (and therefore state derivatives). The output of this layer consists of 16 output nodes and a <em>tanh</em> activation function. The next layer has 16 input and output nodes with the same activation function. The last layer is again a dense layer with 16 input nodes and the number of states as outputs. Here, it is important that no <em>tanh</em>-activation function follows, because otherwise the pendulums state values would be limited to the interval <span>$[-1;1]$</span>.</p><pre><code class="language-julia"># NeuralFMU setup
numStates = fmiGetNumberOfStates(simpleFMU)

net = Chain(inputs -&gt; fmiEvaluateME(simpleFMU, inputs),
            Dense(numStates, 16, tanh),
            Dense(16, 16, tanh),
            Dense(16, numStates))</code></pre><pre><code class="language-none">Chain(
  var&quot;#11#12&quot;(),
  Dense(2, 16, tanh),                   [90m# 48 parameters[39m
  Dense(16, 16, tanh),                  [90m# 272 parameters[39m
  Dense(16, 2),                         [90m# 34 parameters[39m
)[90m                   # Total: 6 arrays, [39m354 parameters, 1.758 KiB.</code></pre><h4 id="Definition-of-the-NeuralFMU"><a class="docs-heading-anchor" href="#Definition-of-the-NeuralFMU">Definition of the NeuralFMU</a><a id="Definition-of-the-NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-NeuralFMU" title="Permalink"></a></h4><p>The instantiation of the ME-NeuralFMU is done as a one-liner. The FMU (<em>simpleFMU</em>), the structure of the network <code>net</code>, start <code>tStart</code> and end time <code>tStop</code>, the numerical solver <code>Tsit5()</code> and the time steps <code>tSave</code> for saving are specified.</p><pre><code class="language-julia">neuralFMU = ME_NeuralFMU(simpleFMU, net, (tStart, tStop), Tsit5(); saveat=tSave);</code></pre><h4 id="Plot-before-training"><a class="docs-heading-anchor" href="#Plot-before-training">Plot before training</a><a id="Plot-before-training-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-before-training" title="Permalink"></a></h4><p>Here the state trajactory of the <em>simpleFMU</em> is recorded. Doesn&#39;t really look like a pendulum yet, but the system is random initialized by default. In the later plots, the effect of learning can be seen.</p><pre><code class="language-julia">solutionBefore = neuralFMU(x₀, tStart)
fmiPlot(simpleFMU, solutionBefore)</code></pre><p><img src="../simple_hybrid_ME_files/simple_hybrid_ME_30_0.svg" alt="svg"/></p><h4 id="Training-of-the-NeuralFMU"><a class="docs-heading-anchor" href="#Training-of-the-NeuralFMU">Training of the NeuralFMU</a><a id="Training-of-the-NeuralFMU-1"></a><a class="docs-heading-anchor-permalink" href="#Training-of-the-NeuralFMU" title="Permalink"></a></h4><p>For the training of the NeuralFMU the parameters are extracted. The known ADAM optimizer for minimizing the gradient descent is used as further passing parameters. In addition, the previously defined loss and callback function, as well as the number of epochs are passed.</p><pre><code class="language-julia"># train
paramsNet = Flux.params(neuralFMU)

optim = ADAM()
Flux.train!(lossSum, paramsNet, Iterators.repeated((), 300), optim; cb=callb) </code></pre><pre><code class="language-none">┌ Info: Loss [1]: 0.07528   Avg displacement in data: 0.27437
└ @ Main In[12]:8
┌ Info: Loss [21]: 0.04558   Avg displacement in data: 0.2135
└ @ Main In[12]:8
┌ Info: Loss [41]: 0.04354   Avg displacement in data: 0.20867
└ @ Main In[12]:8
┌ Info: Loss [61]: 0.04236   Avg displacement in data: 0.20582
└ @ Main In[12]:8
┌ Info: Loss [81]: 0.04193   Avg displacement in data: 0.20478
└ @ Main In[12]:8
┌ Info: Loss [101]: 0.04153   Avg displacement in data: 0.20379
└ @ Main In[12]:8
┌ Info: Loss [121]: 0.04094   Avg displacement in data: 0.20233
└ @ Main In[12]:8
┌ Info: Loss [141]: 0.04003   Avg displacement in data: 0.20008
└ @ Main In[12]:8
┌ Info: Loss [161]: 0.03917   Avg displacement in data: 0.19793
└ @ Main In[12]:8
┌ Info: Loss [181]: 0.03808   Avg displacement in data: 0.19515
└ @ Main In[12]:8
┌ Info: Loss [201]: 0.03616   Avg displacement in data: 0.19016
└ @ Main In[12]:8
┌ Info: Loss [221]: 0.0313   Avg displacement in data: 0.17692
└ @ Main In[12]:8
┌ Info: Loss [241]: 0.01322   Avg displacement in data: 0.11497
└ @ Main In[12]:8
┌ Info: Loss [261]: 0.006   Avg displacement in data: 0.07743
└ @ Main In[12]:8
┌ Info: Loss [281]: 0.00461   Avg displacement in data: 0.06793
└ @ Main In[12]:8</code></pre><h4 id="Comparison-of-the-plots"><a class="docs-heading-anchor" href="#Comparison-of-the-plots">Comparison of the plots</a><a id="Comparison-of-the-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-the-plots" title="Permalink"></a></h4><p>Here three plots are compared with each other and only the position of the mass is considered. The first plot represents the <em>simpleFMU</em>, the second represents the <em>realFMU</em> (reference) and the third plot represents the result after training the NeuralFMU. </p><pre><code class="language-julia"># plot results mass.s
solutionAfter = neuralFMU(x₀, tStart)

fig = Plots.plot(xlabel=&quot;t [s]&quot;, ylabel=&quot;mass position [m]&quot;, linewidth=2,
                 xtickfontsize=12, ytickfontsize=12,
                 xguidefontsize=12, yguidefontsize=12,
                 legendfontsize=8, legend=:topright)

posNeuralFMU = collect(data[1] for data in solutionAfter.u)

Plots.plot!(fig, tSave, posSimple, label=&quot;SimpleFMU&quot;, linewidth=2)
Plots.plot!(fig, tSave, posReal, label=&quot;RealFMU&quot;, linewidth=2)
Plots.plot!(fig, tSave, posNeuralFMU, label=&quot;NeuralFMU (300 epochs)&quot;, linewidth=2)
fig </code></pre><p><img src="../simple_hybrid_ME_files/simple_hybrid_ME_34_0.svg" alt="svg"/></p><h4 id="Continue-training-and-plotting"><a class="docs-heading-anchor" href="#Continue-training-and-plotting">Continue training and plotting</a><a id="Continue-training-and-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Continue-training-and-plotting" title="Permalink"></a></h4><p>As can be seen from the previous figure, the plot of the NeuralFMU has not yet fully converged against the <em>realFMU</em>, so the training of the NeuralFMU is continued. After further training, the plot of <em>NeuralFMU</em> is added to the figure again. The effect of the longer training is well recognizable, since the plot of the NeuralFMU had further converged. </p><pre><code class="language-julia">Flux.train!(lossSum, paramsNet, Iterators.repeated((), 700), optim; cb=callb) 
# plot results mass.s
solutionAfter = neuralFMU(x₀, tStart)
posNeuralFMU = collect(data[1] for data in solutionAfter.u)
Plots.plot!(fig, tSave, posNeuralFMU, label=&quot;NeuralFMU (1000 epochs)&quot;, linewidth=2)
fig </code></pre><pre><code class="language-none">┌ Info: Loss [301]: 0.00412   Avg displacement in data: 0.06419
└ @ Main In[12]:8
┌ Info: Loss [321]: 0.00379   Avg displacement in data: 0.0616
└ @ Main In[12]:8
┌ Info: Loss [341]: 0.0035   Avg displacement in data: 0.05918
└ @ Main In[12]:8
┌ Info: Loss [361]: 0.00322   Avg displacement in data: 0.05673
└ @ Main In[12]:8
┌ Info: Loss [381]: 0.00295   Avg displacement in data: 0.05432
└ @ Main In[12]:8
┌ Info: Loss [401]: 0.0027   Avg displacement in data: 0.05199
└ @ Main In[12]:8
┌ Info: Loss [421]: 0.00246   Avg displacement in data: 0.04961
└ @ Main In[12]:8
┌ Info: Loss [441]: 0.00223   Avg displacement in data: 0.04724
└ @ Main In[12]:8
┌ Info: Loss [461]: 0.00201   Avg displacement in data: 0.0448
└ @ Main In[12]:8
┌ Info: Loss [481]: 0.00179   Avg displacement in data: 0.04236
└ @ Main In[12]:8
┌ Info: Loss [501]: 0.00159   Avg displacement in data: 0.03988
└ @ Main In[12]:8
┌ Info: Loss [521]: 0.0014   Avg displacement in data: 0.03736
└ @ Main In[12]:8
┌ Info: Loss [541]: 0.00121   Avg displacement in data: 0.03481
└ @ Main In[12]:8
┌ Info: Loss [561]: 0.00104   Avg displacement in data: 0.03221
└ @ Main In[12]:8
┌ Info: Loss [581]: 0.00087   Avg displacement in data: 0.02957
└ @ Main In[12]:8
┌ Info: Loss [601]: 0.00072   Avg displacement in data: 0.02692
└ @ Main In[12]:8
┌ Info: Loss [621]: 0.00059   Avg displacement in data: 0.02432
└ @ Main In[12]:8
┌ Info: Loss [641]: 0.00048   Avg displacement in data: 0.02189
└ @ Main In[12]:8
┌ Info: Loss [661]: 0.00039   Avg displacement in data: 0.01966
└ @ Main In[12]:8
┌ Info: Loss [681]: 0.00031   Avg displacement in data: 0.01768
└ @ Main In[12]:8
┌ Info: Loss [701]: 0.00026   Avg displacement in data: 0.01598
└ @ Main In[12]:8
┌ Info: Loss [721]: 0.00021   Avg displacement in data: 0.01447
└ @ Main In[12]:8
┌ Info: Loss [741]: 0.00017   Avg displacement in data: 0.01323
└ @ Main In[12]:8
┌ Info: Loss [761]: 0.00015   Avg displacement in data: 0.0123
└ @ Main In[12]:8
┌ Info: Loss [781]: 0.00013   Avg displacement in data: 0.01157
└ @ Main In[12]:8
┌ Info: Loss [801]: 0.00012   Avg displacement in data: 0.01099
└ @ Main In[12]:8
┌ Info: Loss [821]: 0.00011   Avg displacement in data: 0.01054
└ @ Main In[12]:8
┌ Info: Loss [841]: 0.0001   Avg displacement in data: 0.01017
└ @ Main In[12]:8
┌ Info: Loss [861]: 0.0001   Avg displacement in data: 0.00983
└ @ Main In[12]:8
┌ Info: Loss [881]: 9.0e-5   Avg displacement in data: 0.00958
└ @ Main In[12]:8
┌ Info: Loss [901]: 9.0e-5   Avg displacement in data: 0.00936
└ @ Main In[12]:8
┌ Info: Loss [921]: 8.0e-5   Avg displacement in data: 0.00917
└ @ Main In[12]:8
┌ Info: Loss [941]: 8.0e-5   Avg displacement in data: 0.00901
└ @ Main In[12]:8
┌ Info: Loss [961]: 8.0e-5   Avg displacement in data: 0.00887
└ @ Main In[12]:8
┌ Info: Loss [981]: 8.0e-5   Avg displacement in data: 0.00875
└ @ Main In[12]:8</code></pre><p><img src="../simple_hybrid_ME_files/simple_hybrid_ME_36_1.svg" alt="svg"/></p><p>Finally, the FMU is cleaned-up.</p><pre><code class="language-julia">fmiUnload(simpleFMU)</code></pre><h3 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h3><p>Based on the plots, it can be seen that the NeuralFMU is able to adapt the friction model of the <em>realFMU</em>. After 300 runs, the curves do not overlap very well, but this can be achieved by longer training (1000 runs) or a better initialization.</p><h3 id="Source"><a class="docs-heading-anchor" href="#Source">Source</a><a id="Source-1"></a><a class="docs-heading-anchor-permalink" href="#Source" title="Permalink"></a></h3><p>[1] Tobias Thummerer, Lars Mikelsons and Josef Kircher. 2021. <strong>NeuralFMU: towards structural integration of FMUs into neural networks.</strong> Martin Sjölund, Lena Buffoni, Adrian Pop and Lennart Ochel (Ed.). Proceedings of 14th Modelica Conference 2021, Linköping, Sweden, September 20-24, 2021. Linköping University Electronic Press, Linköping (Linköping Electronic Conference Proceedings ; 181), 297-306. <a href="https://doi.org/10.3384/ecp21181297">DOI: 10.3384/ecp21181297</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simple_hybrid_CS/">« Simple CS-NeuralFMU</a><a class="docs-footer-nextpage" href="../modelica_conference_2021/">Modelica Conference 2021 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 11 March 2022 10:16">Friday 11 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
